<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<!-- saved from url=(0071)http://www.troubleshooters.com/lpm/200212/200212.htm#_VI_Life_Preserver -->
<html class="gr__troubleshooters_com"><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
  <meta name="Author" content="Steve Litt">
  <meta name="GENERATOR" content="Mozilla/4.78 [en] (X11; U; Linux 2.4.18-6mdksmp i686) [Netscape]">
  <meta name="Description" content="Using the Zope Portal Building Software">
  <meta name="Keywords" content="Zope,website,websites,portal,portals,web portal,web authoring,web authoring tool,web authoring tools,web app,web application,web applications,Python,Zope Corporation,Digital Creations"><title>December 2002 Linux Productivity Magazine: VI and Vim</title><style id="style-1-cropbar-clipper">/* Copyright 2014 Evernote Corporation. All rights reserved. */
.en-markup-crop-options {
    top: 18px !important;
    left: 50% !important;
    margin-left: -100px !important;
    width: 200px !important;
    border: 2px rgba(255,255,255,.38) solid !important;
    border-radius: 4px !important;
}

.en-markup-crop-options div div:first-of-type {
    margin-left: 0px !important;
}
</style><script type="text/javascript" src="./December 2002 Linux Productivity Magazine_ VI and Vim_files/scoop.js.download"></script><link type="text/css" rel="stylesheet" href="./December 2002 Linux Productivity Magazine_ VI and Vim_files/bklet_external_scpWindow.css" media="screen"></head><body text="#000000" bgcolor="#ffffff" link="#0000ee" vlink="#551a8b" alink="#ff0000" data-gr-c-s-loaded="true" data-pinterest-extension-installed="cr2.0.5"><iframe id="iframeUnderDivToShowOverFlash" frameborder="0" allowtransparency="true" class=" scoopit-hulk" style="display: none; height: 24303px;" src="./December 2002 Linux Productivity Magazine_ VI and Vim_files/saved_resource.html"></iframe><div id="sc_bookmarklet" class="scoopit-hulk v4" style="height: 24303px; display: none;"><div id="sc_main" style="top: 17274.8px;" class=" scoopitWindowSuccessBookmarklet">    <iframe id="sc_iframe" frameborder="0" name="sc_bookmarklet_iframe" src="./December 2002 Linux Productivity Magazine_ VI and Vim_files/bookmarklet.html"></iframe>        &nbsp;    </div></div>
<a name="starthdr"></a>
<center><b><font size="+2"><a href="http://www.troubleshooters.com/troubleshooters.htm">Troubleshooters.Com
Presents</a></font></b></center>






<p><br>
</p>




<center><table border="4" cellpadding="8" bgcolor="#000066" nosave="">
<tbody><tr nosave="">
<td nosave="">
<center><font size="+4"><b><font color="#ffffee">Linux Productivity Magazine</font></b>
</font><p><font size="+4"><font size="+1"><b><font color="#eeffff">Volume 1 Issue 5, December 2002</font></b></font>
<br><b><font color="#eeffff"><font size="+2">VI and Vim</font></font></b></font></p></center>
</td>
</tr>
</tbody></table></center>



<center><table border="5" cellspacing="0" cellpadding="5" width="96%" bgcolor="#fffff0" nosave="">
<tbody><tr nosave="">
</tr>
</tbody></table></center>



<h1>
<a name="_Elementary_Search_and_Replace_and_Global_Commands"></a>Search and Replace: Substitute and Global Commands</h1>


<h2><a name="Ranges"></a>Ranges</h2>


<table cellpadding="2" cellspacing="2" border="1">


  <tbody>
    <tr>
      <td valign="top" bgcolor="#cccccc">Range<br>
      </td>
      <td valign="top" bgcolor="#cccccc">Example<br>
      </td>
      <td valign="top" bgcolor="#cccccc">Explanation<br>
      </td>
    </tr>
    <tr>
      <td valign="top">4,7<br>
      </td>
      <td valign="top">:4,7s/Windows/Linux/<br>
      </td>
      <td valign="top">Runs the substitution command on lines 4 through 7 inclusive.<br>
      </td>
    </tr>
    <tr>
      <td valign="top">4;7<br>
      </td>
      <td valign="top">:4;7s/Windows/Linux/</td>
      <td valign="top">Runs the substitution command on line 4, and the 7
lines following it. Note the distinction between the semicolon version, which
calculates the second value relative to the first.<br>
      </td>
    </tr>
    <tr>
      <td valign="top">4<br>
      </td>
      <td valign="top">:4s/Windows/Linux/</td>
      <td valign="top">Runs the substitution command on line 4 only.<br>
      </td>
    </tr>
    <tr>
      <td valign="top">4,$<br>
      </td>
      <td valign="top">:4,$s/Windows/Linux/</td>
      <td valign="top">Runs the substitution command on lines 4 through the
file's last line, inclusive. In line ranges, the &nbsp;$ character represents
the last line in the file.</td>
    </tr>
    <tr>
      <td valign="top">4,.<br>
      </td>
      <td valign="top">:4,.s/Windows/Linux/</td>
      <td valign="top">Runs the substitution command on lines 4 through the line the cursor is on, inclusive.
In line ranges, the . character represents the current line.</td>
    </tr>
    <tr>
      <td valign="top">.,2000<br>
      </td>
      <td valign="top">:.,2000s/Windows/Linux/</td>
      <td valign="top">Runs the substitution command on the current line
through line 2000 inclusive. This shows that the dot can be used as the beginning,
or as the end of a range.</td>
    </tr>
    <tr>
      <td valign="top">.,.+3<br>
      </td>
      <td valign="top">:.,.+3s/Windows/Linux/</td>
      <td valign="top">Runs the substitution command on the current line
through the line three below the current line inclusive. In other words,
this line plus the next three. In general, you add and subtract from a range
value by appending a plus and number, or a minus and number. Be careful not
to go too far or too short by one -- it's easy to do.</td>
    </tr>
    <tr>
      <td valign="top">.,+3</td>
      <td valign="top">:.,+3s/Windows/Linux/</td>
      <td valign="top">CAREFUL!!! This produces the identical result to the
preceding example, even though we removed the dot in the range end expression.
In a + or - expression, if what it's relative is not explicitly declared,
it defaults to "current line". This can lead to confusion. Use the version
with the dot.<br>
      </td>
    </tr>
    
    <tr>
      <td valign="top"><small><small>/My_Opinion/,$</small></small><br>
      </td>
      <td valign="top"><small><small>:/My_Opinion/,$s/Windows/Linux/</small></small></td>
      <td valign="top">Search forward for the next occurrence of My_Opinion,
and run the substitution on that line through the end of file, inclusive.
Note that the search will not find matches on the current line.</td>
    </tr>
  </tbody>
</table>


<h3>Searches in Ranges</h3>


The final example in the preceding table shows a search in a range. This
makes VI incredibly powerful, and if done casually incredibly dangerous.
But here let's discuss the power. A search can appear in either the range
start expression, the range end expression, or both. The search can be forward
or backward. The line found by the search can be added to or subtracted from.<br>


<br>


<table cellpadding="2" cellspacing="2" border="1" width="50%" align="center">


  <tbody>
    <tr>
      <td valign="top">
      <div align="center"><font size="+1" color="#cc0000"><b>WARNING</b></font><br>
      </div>
If you have wrapscan set, searches in ranges can do some strange things.
A forward search can fail to find the string by end of file, wrap back up,
and find one above where you are. Likewise, a backward search can wrap around
the top and find a match below you. These typically are not what you want.<br>
      <br>
To make your results more predictable, before running commands with searches
in ranges, turn off wrapscan with the following command:<br>
      <pre>:set nowrapscan</pre>
Later, if you want to restore wrapscan so you can find a pattern anywhere in the file, restore it with this command:<br>
      <pre>:set wrapscan</pre>
      </td>
    </tr>
  </tbody>
</table>


<br>


Remembering to set nowrapscan, see the following examples:<br>


<br>


<table cellpadding="2" cellspacing="2" border="1">


  <tbody>
    <tr>
      <td valign="top" bgcolor="#cccccc">Range<br>
      </td>
      <td valign="top" bgcolor="#cccccc">Function<br>
      </td>
      <td valign="top" bgcolor="#cccccc">Explanation<br>
      </td>
    </tr>
    <tr>
      <td valign="top">:/My_Opinion/,$s/Windows/Linux/</td>
      <td valign="top">Search forward<br>
      </td>
      <td valign="top">Search forward from the current line to the next line
containing "My_Opinion", and from that line to the end of file substitute
"Linux" for "Windows". The search WILL NOT match any "My_Opinion" on the
current line, and instead will match the next downward occurrence of "My_Opinion".</td>
    </tr>
    <tr>
      <td valign="top">:?My_Opinion?,$s/Windows/Linux/</td>
      <td valign="top">Search backward<br>
      </td>
      <td valign="top">Search backward from the current line to the next line up containing "My_Opinion",
and from that line to the end of file substitute "Linux" for "Windows". The
search WILL NOT match any "My_Opinion" on the current line.
The search WILL NOT match any "My_Opinion" on the current line, and instead
will match the next upward occurrence of "My_Opinion".</td>
    </tr>
    <tr>
      <td valign="top">:1+/My_Opinion/,$s/Windows/Linux/</td>
      <td valign="top">Search forward from line 1<br>
      </td>
      <td valign="top">The previous searches started from the current line,
which may or may not be what you want. If starting the command with a known
state is important to you, use this command form to start from line 1. Note
that this will not find a match on line 1, so if that's an issue you'll need
to run an additional command to get the lines you missed.<br>
      </td>
    </tr>
    <tr>
      <td valign="top">:2+?My_Opinion?;/My_Opinion/-1s/Windows/Linux/<br>
      </td>
      <td valign="top">See comment<br>
      </td>
      <td valign="top">If the first line contains "My_Opinion", the preceding
command did not substitute on that line or any lines until the next occurrence
of "My_Opinion". You probably want those lines substituted. This command
does that. Starting at line 2, it goes backward (you did set nowrapscan to
prevent search wrapping, didn't you?), and if it finds "My_Opinion" on line
1, it alters line 1 and every line until, and including, the line before
the next "My_Opinion", which presumably was fixed by the preceding command.<br>
      </td>
    </tr>
  </tbody>
</table>


<h3>WYSIWYG Ranges</h3>


Consider the preceding range substitution:<br>


<pre>:2+?My_Opinion?;/My_Opinion/-1s/Windows/Linux/</pre>


Can you glance at that command and tell what it does? Not unless you're a true VimMeister. Personally, I'm not that good.<br>


<br>


The classic early 1980's post titled "Real Men Don't Use Pascal" discusses
the wonders of "You asked for it, you got it" (YAFIYGI) editors like DEC's
TECO, in which a single wrong character can destroy the file. The preceding
command just might involve just a little too much "you asked for it, you got it" risk for
someone on a tight deadline.<br>


<br>


When you need to play it safe, many VI implementations have something called
Visual Mode, in which you can highlight a certain range of lines, and run
a simple substitution on that range. For instance, in the Vim implementation,
you'd go to the first line you want to change, press Shift+V, then use motion
commands, such as j or a search, to move to the end of the range. Once the
desired range is highlighted, you simply press the colon key, and then type
<tt>s/Windows/Linux/</tt> to make the change in the highlighted area.<br>


<br>


Generally speaking, when you're making range changes in realtime, if you
have Visual Mode available, you'll use it to simplify ranges.<br>


<br>


And of course, when you want to show off at your LUG, you use the YAFIYGI
method. After all, real men use TECO when they can, and if TECO isn't available,
they use VI recklessly.<br>


<h2>Global Commands</h2>


Real men and quiche-eating Pascal programmers alike love VI's Global commands.
The real man can destroy an entire file with this 8 character command:<br>


<pre>:g/the/d<br></pre>


Or he can hide his tracks from quiche-eating Pascal Programmers by combining
it with an obfuscatory substitute command like this:<br>


<pre>:1+/friend/;/lover/g/Madonna/+2s/singer/singer,actress/<br></pre>


If you're a Pascal Programmer (or the modern equivalent, a Java Jockey) interested in knowing what the preceding command does, <a href="http://www.troubleshooters.com/lpm/200212/quiche_answer.htm">click here</a>. To real men the preceding is intuitively obvious to the most casual observer.<br>


<br>


Quiche eaters also love Global commands. When the boss expects the huge production
produced by quiche-eating rapid development techniques, your editing needs
to be lightning quick. Consider how often you need to pick out only lines
containing "whatever" from a huge file. Edit a duplicate copy of the file
with VI, and run the following command:<br>


<pre>:g!/whatever/d<br></pre>


The preceding command deletes every line not containing "whatever". But what
if you need only lines containing "whatever" and "whichever"? Watch this:<br>


<pre>:g/whatever/.w&gt;&gt;w.txt<br>:g/whichever/.w&gt;&gt;w.txt<br></pre>


Try it. Create a data file with lines consisting of either "whatever", "whichever"
or "whyever". Then, so you can be assured that all lines are copied in the
order they're found, prepend line numbers to every line with the following
command:<br>


<pre>:%!cat -n<br></pre>


Global commands are also an excellent way to perform a substitution on only
a certain class of lines. The following changes the word "judgment" to "ripoff"
on any line containing "microsoft antitrust":<br>


<pre>:g/microsoft antitrust/s/judgment/ripoff/<br></pre>


The cool thing about the preceding is the word "judgment" can appear anywhere
in relation to the word "microsoft antitrust", and yet the deed will be done.
Perhaps you want to make the change anywhere near the word "microsoft antitrust",
where "anywhere near" is defined as the line, or anything within 2 lines
before it or 2 lines after it. Watch this:<br>


<pre>:g/microsoft antitrust/-2,+2s/judgment/ripoff/c<br></pre>


You notice the c (for confirm) at the end? Any time you do anything as adventurous
as the preceding, you want to check your work. It would be terrible to write
an article and inadvertently change "I used my best judgment" to "I used
my best ripoff".<br>


<h3>The Anatomy of a Global Command</h3>


The following are how a global command is built. The first runs the command
on every line within the range that matches the pattern. The second runs
the command on every line within the range that DOESN'T match the pattern:<br>


<pre>:[range]g/{pattern}/[command]</pre>


<pre>:[range]g!/{pattern}/[command]</pre>


If the range is not given (and it usually is not), the default range is every
line in the file. The concept is simple enough. The command is run on every
matching (or non-matching with the exclamation point form) line. Where it
gets more complex is when the command gets complex.<br>


<h3>Real Life Global Commands</h3>


Certainly the simplest command is the delete command:<br>


<pre>:g/#/d</pre>


The preceding deletes every line with a pound sign. The following deletes every line that DOES NOT contain the pound sign:<br>


<pre>:g!/#/d</pre>


The global command is often used to move certain classes of lines to a second file:<br>


<pre>:g!/^\t\t/.w&gt;&gt;top2levels.otl</pre>


The preceding command appends all lines that don't start with 2 tabs. In
a tab-indented outline, that would be the top 2 levels. The carat at the
start of the pattern is a wildcard representing start of line, as will be
explained in the <a href="http://www.troubleshooters.com/lpm/200212/200212.htm#_Regular_Expressions">article on regular expressions</a>.<br>


<br>


Another common command used with the Global command is the substitute command.
In this case the substitute command substitutes based on a criteria totally
different from the criteria by which the line is chosen. Typically the pattern
by which the line is chosen can occur anywhere on the line in relation to
the substitute command, so you cannot include the selection criteria in a
single substitute command. Even when the selection criteria is predictable,
the global command often simplifies it. Which would you rather do:<br>


<pre>:g/^master_/s/slave/SLAVE/g<br></pre>


or<br>


<pre>:%s/^\(master_.*\)slave/\1SLAVE/g<br></pre>


The latter command uses groups to "remember" the match, and places that remembered text in the replace text in the form of <tt>\1</tt>.
Even the somewhat convoluted second form is not completely accurate, because
if there are multiple instances of the word "slave", VI's native long matching
will cause it to only change the last instance of "slave" on each line. Long
and short matching are explained in the <a href="http://www.troubleshooters.com/lpm/200212/200212.htm#_Regular_Expressions">article on regular expressions</a>.<br>


<h2>Summary</h2>


Substitute and Global commands offer immense power, but that fact is not
obvious from this article. After all, most examples in this article simply
looked for one string and replaced it with another. Ranges added some power,
and so did the one-two punch of a Global command whose command upon match is a Substitute command. <br>


<br>


But until you introduce Regular Expressions, the Global and Substitute commands
are just parlor tricks of a second rate magician. Regular Expressions transmogrify
these commands into wizardry. Read on...<br>


<h5>Steve Litt is the author of "<a href="http://www.troubleshooters.com/bookstore/ttech.htm"> Troubleshooting
Techniques of the Successful Technologist</a>".&nbsp; Steve can be reached
at <a href="http://www.troubleshooters.com/email_steve_litt.htm">Steve Litt's email address</a>
.</h5>








<h1>
</h1>










<h1>
<a name="_Regular_Expressions"></a>Regular Expressions</h1>






<h5>
By Steve Litt</h5>

VI is the most powerful editor I've seen. It absolutely
dwarfs the WordPerfect editor I loved for so many years. The person truly adept
at VI can accomplish file translations and conversions typically requiring
a computer program. Indeed, I've written Vim scripts that convert a VimOutliner
outline to an htmlslides presentation. Another script reads an issue of Troubleshooting
Professional Magazine or Linux Productivity Magazine and creates a table
of contents that can be pasted into the magazine. Yet another converts a
tab-indented outline into a LyX document. Yet another formats data pasted
from my sales database into mailing labels. These are very simple scripts
-- not a one is more than 20 lines.<br>


<br>


Better yet, VI can be used on the fly to do work usually requiring programming.
I've taken data files and converted them to a program to produce them. I've
added, deleted and reordered fields in fixed length and comma delimited data
files. <br>


<br>


Regular expressions are a fundamental component of this power. Simply put,
regular expressions are searchable expressions that match a class of strings
in the file. As a basic example, the following VI search command:<br>


<pre>/web\s*master</pre>


matches "webmaster", or "web master", or "web &nbsp; &nbsp; &nbsp;master",
because \s represents a single character of any whitespace, and an asterisk
means "zero or more of the preceding character". Here are some other examples:<br>


<br>


<table cellpadding="2" cellspacing="2" border="1" width="100%">


  <tbody>
    <tr>
      <td valign="top" width="50%"><b><tt>/[aeiouAEIOU]</tt></b><br>
      </td>
      <td valign="top">Find the next vowel.<br>
      </td>
    </tr>
    <tr>
      <td valign="top"><b><tt>/[^aeiouAEIOU[:space:][:punct:][:digit:]]</tt></b><br>
      </td>
      <td valign="top">Find the next non-vowel letter.<br>
      </td>
    </tr>
    <tr>
      <td valign="top"><b><tt>:%s/Windows/Linux/g</tt></b><br>
      </td>
      <td valign="top">Replace all instances of "Windows" with "Linux".<br>
      </td>
    </tr>
    <tr>
      <td valign="top"><b><tt>:%s/\([^,]*\),\([^,]*\),\(.*\)/\2,\1,\3/</tt></b><br>
      </td>
      <td valign="top">Exchange the first two fields in each row of a file of comma delimited records.<br>
      </td>
    </tr>
    <tr>
      <td valign="top"><b><tt>:s/\&lt;\(.\)\([^[:space:][:punct:]]*\)\&gt;/\u\1\2/g</tt></b>
      </td>
      <td valign="top">Capitalizes the first letter of every word on a line (title case converter)<br>
      </td>
    </tr>
  </tbody>
</table>


<br>


That's some pretty serious power for the person expert at creating regular
expressions. Entire books have been written about regular expressions. However,
this article will give you the 10% to do 90% of what you need to do in VI.<br>


<h2>Character Sets</h2>


A character set is a wildcard. When compared to a character, there is a match
if the character is one of those in the character set. There are several
types of character sets, but the most basic is a list of matching characters
inside of brackets. For example, <tt>[aeiou]</tt> matches any lower case vowel. The list could be a range like <tt>[0-9]</tt>, which matches any decimal digit. The brackets can contain a combination. For instance, <tt>[0-9.]</tt> matches any decimal digit or a decimal point (within brackets a dot is NOT a wildcard).<br>


<br>


If the characters inside of the brackets start with a carat (<tt>^</tt>), the character set matches anything except the characters inside the brackets. So <tt>[^a-zA-Z]</tt>
matches any character except a letter in the alphabet. If you actually want
to match a carat, simply make it not the first character, as in <tt>[@^#]</tt>, which matches either an at sign, a carat, or a pound sign.<br>


<br>


<table cellpadding="2" cellspacing="2" border="1" width="50%" align="center">


  <tbody>
    <tr>
      <td valign="top">
      <div align="center"><b><font size="+1">IMPORTANT</font></b><br>
      </div>
      <br>
A character set matches only a single character. It cannot match a phrase.
It is only when character sets are grouped with other character sets, other
characters, and iterators, that they can match phrases.<br>
      </td>
    </tr>
  </tbody>
</table>


<br>


<br>


Many character sets are so common that VI shortcuts are provided for them. Here are some character set shortcuts:<br>


<br>


<table border="1" cellpadding="3" nosave="">



<tbody><tr nosave="">
<td nosave="" bgcolor="#cccccc"><b><tt>Shortcut</tt></b></td>

<td bgcolor="#cccccc"><b><tt>Equivalent
      <br>
Character
      <br>
Set</tt></b></td>

<td bgcolor="#cccccc">What it matches</td>
</tr>

<tr>
<td><b><tt>\d</tt></b></td>

<td><b><tt>[0-9]</tt></b></td>

<td>digit</td>
</tr>

<tr>
<td><b><tt>\D</tt></b></td>

<td><b><tt>[^0-9]</tt></b></td>

<td>Any character except a digit</td>
</tr>

<tr>
<td><b><tt>\s</tt></b></td>

<td><b><tt>[ \t\n\r]</tt></b></td>

<td>whitespace</td>
</tr>

<tr>
<td><b><tt>\S</tt></b></td>

<td><b><tt>[^ \t\n\r]</tt></b></td>

<td>Any character that is not whitespace</td>
</tr>

<tr>
<td><b><tt>\w</tt></b></td>

<td><b><tt>[a-zA-Z0-9]</tt></b></td>

<td>"word char" : i.e. alphanumeric, not space or punctuation</td>
</tr>

<tr>
<td><b><tt>\W</tt></b></td>

<td><b><tt>[^a-zA-Z0-9]</tt></b></td>

<td>"word separator" : i.e. space or punctuation, also
not EOL or BOL</td>
</tr><tr>
      <td valign="top">\l<br>
      </td>
      <td valign="top">[a-z]<br>
      </td>
      <td valign="top">Lowercase
letter. In the search expression it matches any lower case letter. In the
replace expression it lowercases the character or character representer following
it.<br>
      </td>
    </tr>
    <tr>
      <td valign="top">\L<br>
      </td>
      <td valign="top">[^a-z]<br>
      </td>
      <td valign="top">In the search expression \L matches any character except except a lowercase letter.
In the replace expression it makes everything that follows it, to the end
of the replace expression, lower case. However, a later \U in the replace
expression ends its effect.<br>
      </td>
    </tr>
    <tr>
      <td valign="top">\u<br>
      </td>
      <td valign="top">[A-Z]<br>
      </td>
      <td valign="top">Uppercase
letter.  In the search expression it matches any lower case letter. In the
replace expression it capitalizes the character following it.       </td>
    </tr>
    <tr>
      <td valign="top">\U<br>
      </td>
      <td valign="top">[^A-Z]<br>
      </td>
      <td valign="top">In the search expression \U matches any character except except an uppercase letter.
In the replace expression it makes everything that follows it, to the end
of the replace expression, upper case. However, a later \L in the replace
expression ends its effect.
      </td>
    </tr>

</tbody>
</table>


<br>


What do you do if you need to match a control character like &nbsp;a newline,
carriage return, escape character or tab? In the UNIX world you could construct
the unprintable by pressing Ctrl+V followed by the control character (Ctrl+M
for the carriage return character, for instance). But that's ugly. A much
better solution is to use the following character representers:<br>


<br>


<table cellpadding="2" cellspacing="2" border="1">


  <tbody>
    <tr>
      <td valign="top" bgcolor="#cccccc">Character Representer<br>
      </td>
      <td valign="top" bgcolor="#cccccc">What it represents<br>
      </td>
    </tr>
    <tr>
      <td valign="top">\e<br>
      </td>
      <td valign="top">The Escape character (decimal 27)<br>
      </td>
    </tr>
    <tr>
      <td valign="top">\t<br>
      </td>
      <td valign="top">The Tab character<br>
      </td>
    </tr>
    <tr>
      <td valign="top">\r<br>
      </td>
      <td valign="top">The carriage return character (looks like ^M in VI)<br>
      </td>
    </tr>
    <tr>
      <td valign="top">\b<br>
      </td>
      <td valign="top">The Backspace character<br>
      </td>
    </tr>
    <tr>
      <td valign="top">\n<br>
      </td>
      <td valign="top">The end of line character<br>
      </td>
    </tr>
    <tr>
      <td valign="top">.<br>
      </td>
      <td valign="top">Any character<br>
      </td>
    </tr>
  </tbody>
</table>


<br>


There are also special strings that represent positions in a line instead of characters:<br>


<br>


<table cellpadding="2" cellspacing="2" border="1">


  <tbody>
    <tr>
      <td valign="top" bgcolor="#cccccc">Positional<br>
Representer<br>
      </td>
      <td valign="top" bgcolor="#cccccc">Example<br>
      </td>
      <td valign="top" bgcolor="#cccccc">Meaning<br>
      </td>
    </tr>
    <tr>
      <td valign="top"><tt><b>^<br>
      </b></tt></td>
      <td valign="top"><tt><b>:s/^/cp /</b></tt></td>
      <td valign="top"><tt>^</tt> Means beginning of line. This example "replaces"
the beginning of line with cp followed by a space, creating a copy command
from a directory listing. Note that when you "replace" a positional representer,
there's nothing to replace, so you simply put the replaced text in the position
represented by the positional representer.<br>
      </td>
    </tr>
    <tr>
      <td valign="top"><tt><b>$<br>
      </b></tt></td>
      <td valign="top"><tt><b>:s/$/ backupdir/</b></tt></td>
      <td valign="top"><tt>$</tt> means end of line. This example puts a space followed by <tt>backupdir</tt> at the end of the line, finishing the copy command you started with the carat example.<br>
      </td>
    </tr>
    <tr>
      <td valign="top"><tt><b>\&lt;<br>
      </b></tt></td>
      <td valign="top"><tt><b>:s/\&lt;sed/awk/g</b></tt></td>
      <td valign="top"><tt>\&lt;</tt> means a the word's beginning boundary.
It is neither the first character of the word, nor the whitespace or punctuation
before it, but instead an imaginary position between the two, or in the case
where the word is at the start of the line, it exactly overlays <tt>^</tt>. This example finds every word starting with the string <tt>sed</tt> and replaces that string with <tt>awk</tt>. But, for instance, it would leave the word "ba<i>sed</i>" unharmed, because the string <tt>sed</tt> is not at the beginning of the word.<br>
      </td>
    </tr>
    <tr>
      <td valign="top"><tt><b>\&gt;<br>
      </b></tt></td>
      <td valign="top"><tt><b>:s/\&lt;sed\&gt;/awk/g</b></tt></td>
      <td valign="top"><tt>\&gt;</tt> means a the word's ending boundary. It is neither the last
character of the word, nor the whitespace or punctuation after it, but instead
an imaginary position between the two, or in the case where the word is at
the end of the line, it exactly overlays <tt>$</tt>. This example finds every word <tt>sed</tt> and replaces that word with <tt>awk</tt>. But, for instance, it would leave the word "ba<i>sed</i>" unharmed, and also the word "<i>sed</i>iment", because the string <tt>sed</tt> is not at both the beginning and end of the search pattern.</td>
    </tr>
  </tbody>
</table>


<br>


<br>


Because many characters are used as character representers, character set
shortcuts, and other constructs, they are not available in regular expressions
unless they're escaped. Here's a partial list of characters that must be
escaped:<br>


<br>


<table cellpadding="2" cellspacing="2" border="1" width="100%">


  <tbody>
    <tr>
      <td valign="top">\.<br>
      </td>
      <td valign="top">A literal period<br>
      </td>
    </tr>
    <tr>
      <td valign="top">\\<br>
      </td>
      <td valign="top">A literal backslash<br>
      </td>
    </tr>
    <tr>
      <td valign="top">\/<br>
      </td>
      <td valign="top">A literal forward slash. Note that because of the
forward slash's role in regular expressions, this escape pattern must be
used even in the replace section of search and replace regular expressions.<br>
      </td>
    </tr>
    <tr>
      <td valign="top">\^<br>
      </td>
      <td valign="top">A literal carat. Normally a carat represents "beginning of line".<br>
      </td>
    </tr>
    <tr>
      <td valign="top">\$<br>
      </td>
      <td valign="top">A literal dollar sign. Normally a dollar sign represents "end of line".<br>
      </td>
    </tr>
  </tbody>
</table>


<br>


The VI character set shortcuts discussed so far are handy, but in addition
to those, many VI implementations recognize Posix character set shortcuts,
as shown in the following table:<br>


<br>


<table cellspacing="0" cellpadding="0" nosave="">



<tbody><tr>
<td><b>[[:alnum:]]</b></td>

<td>&nbsp;</td>

<td><b>letters and digits</b></td>
</tr>

<tr>
<td><b>[[:alpha:]]</b></td>

<td><br>
</td>

<td><b>letters</b></td>
</tr>

<tr nosave="">
<td nosave=""><b>[[:blank:]]</b></td>

<td><br>
</td>

<td><b>space and tab characters</b></td>
</tr>

<tr nosave="">
<td><b>[[:cntrl:]]</b></td>

<td><br>
</td>

<td nosave=""><b>control characters</b></td>
</tr>

<tr nosave="">
<td><b>[[:digit:]]</b></td>

<td><br>
</td>

<td nosave=""><b>decimal digits</b></td>
</tr>

<tr>
<td><b>[[:graph:]]</b></td>

<td><br>
</td>

<td><b>printable characters excluding space</b></td>
</tr>

<tr>
<td><b>[[:lower:]]</b></td>

<td><br>
</td>

<td><b>lowercase letters (all letters when 'ignorecase' is used)</b></td>
</tr>

<tr>
<td><b>[[:print:]]</b></td>

<td><br>
</td>

<td><b>printable characters including space</b></td>
</tr>

<tr>
<td><b>[[:punct:]]</b></td>

<td><br>
</td>

<td><b>punctuation characters</b></td>
</tr>

<tr>
<td><b>[[:space:]]</b></td>

<td><br>
</td>

<td><b>whitespace characters</b></td>
</tr>

<tr>
<td><b>[[:upper:]]</b></td>

<td><br>
</td>

<td><b>uppercase letters (all letters when 'ignorecase' is used)</b></td>
</tr>

<tr>
<td><b>[[:xdigit:]]</b></td>

<td><br>
</td>

<td><b>hexadecimal digits</b></td>
</tr>

<tr>
<td><b>[[:return:]]</b></td>

<td><br>
</td>

<td><b>the &lt;CR&gt; character</b></td>
</tr>

<tr>
<td><b>[[:tab:]]</b></td>

<td><br>
</td>

<td><b>the &lt;Tab&gt; character</b></td>
</tr>

<tr>
<td><b>[[:escape:]]</b></td>

<td><br>
</td>

<td><b>the &lt;Esc&gt; character</b></td>
</tr>

<tr>
<td><b>[[:backspace:]]</b></td>

<td><br>
</td>

<td><b>the &lt;BS&gt; character</b></td>
</tr>
</tbody>
</table>


<br>


Remember, a character set is a wildcard against which you can match a single
character. You cannot use it to match a string or phrase, unless you use
enumerators...<br>


<h2>Enumerators</h2>


Enumerators apply to a single character -- the character or character set
that precedes them in the regular expression. An enumerator declares how
many of the preceding character will match. <br>


<br>


The most general form of an iterator is:
<pre>\{n,m}</pre>



The first number (n), is the minimum number of the preceding character needed to create a match. For instance, <br><tt>


A\{2, 4}</tt> matches AA, AAA, or even AAAAAAAAA, but it does not match a single A not followed or preceded by an additional A.<br>


<br>


So you might wonder what the second number is. The second number is how far
you skip before trying to find another match. For instance, take a string
with 13 A characters in a row, preceded and followed by a space.<br>


<pre>/A\{2,4} the first time<br>AAAAAAAAAAAAA<br>^<br><br><br>/A\{2,4} the second time<br>AAAAAAAAAAAAA<br>    ^<br><br><br>/A\{2,4} the third time<br>AAAAAAAAAAAAA<br>        ^<br><br><br>/A\{2,4} the fourth time (no match, because only 1 A remains)<br>AAAAAAAAAAAAA<br>            <br></pre>


The first time it matches the first 4 letters. The second time it matches
the second four. The third time it matches the third four. Now it gets interesting.
It doesn't match the last A because there's only one left. If there had been
14 A's instead of 13, it would have matched the last 2. So the last number
is the maximum match, and the number it skips ahead to begin trying for the
next match.<br>


<br>


Remember also that the character being enumerated can be a character set.
For instance, the following finds strings of 2 to 100 instances of whitespace
(presumably to convert them to nothing, thereby squeezing out repeated spaces)<br>


<pre>\s\{2,100}<br></pre>


That brings up a good point. You really wanted 2 to infinity, not 2 to 100.
Another way of saying 2 to infinity is 2 or more, and the enumerator for
that is <tt>\{2,}</tt>. That matches 2 or more consecutive A characters,
and matches all of them, so that subsequent matches won't match any more
of that consecutive run.<br>


<br>


Perhaps you want to match exactly two of a character. The enumerator for that is <tt>\{2}</tt>. <br>


<br>


There are shortcuts for the most common enumerators, namely, 0 or more, 1 or more, and 0 or 1:<br>


<br>


<table cellpadding="2" cellspacing="2" border="1">


  <tbody>
    <tr>
      <td valign="top" bgcolor="#cccccc">Shortcut<br>
      </td>
      <td valign="top" bgcolor="#cccccc">Equivalent enumerator<br>
      </td>
      <td valign="top" bgcolor="#cccccc">Meaning<br>
      </td>
    </tr>
    <tr>
      <td valign="top">*<br>
      </td>
      <td valign="top">\{0,}<br>
      </td>
      <td valign="top">0 or more<br>
      </td>
    </tr>
    <tr>
      <td valign="top">\+<br>
      </td>
      <td valign="top">\{1,}<br>
      </td>
      <td valign="top">1 or more<br>
      </td>
    </tr>
    <tr>
      <td valign="top">\?<br>
      </td>
      <td valign="top">\{0,1}<br>
      </td>
      <td valign="top">0 or 1<br>
      </td>
    </tr>
  </tbody>
</table>


<br>


The following matches a traditional 10 digit phone number:<br>


<pre>/(\d\{3})[-[:space:]]\?\d\{3}-\d\{4}<br></pre>


The preceding is read as follows:<br>


<br>


An opening paren, followed by exactly three digits, followed by a closing paren, followed by zero or one
instance of either a whitespace character or a dash, followed by exactly
three digits, followed by a dash, followed by exactly four digits.<br>


<br>


Armed with character sets and enumerators, you can search and successfully
find simple to moderately complex patterns. But some things, like locating
phone numbers whether or not they have area codes, and parsing of delimited
lines, require more. Read on...<br>


<h2><a name="Using_Matched_Text_as_Replacement_Text"></a>Using Matched Text as Replacement Text</h2>


Something that comes up with surprising regularity is the need to switch
2 parts of every line. For instance, consider a comma delimited data file.
What if you need to switch the first and second fields? Here's how you do
it:<br>


<pre>:%s/\([^,]*\),\([^,]*\),\(.*\)/\2,\1,\3/<br></pre>


Your first reaction might be that the preceding is ugly. That's true, but
compare it to writing a program or creating a macro like you need to do in
so many other editors.<br>


<br>


Here's a character by character explanation of the preceding command:<br>


<table cellpadding="3">


  <tbody>
    <tr>
      <td valign="top" align="right">
      <pre><b>:%s</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Substitute&nbsp;on every line<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right"><b>/<br>
      </b></td>
      <td valign="top"><br>
      </td>
      <td valign="top">Begin search expression<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\(</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Begin a group. The group is ended by \). Everything
inside a search expression group is remembered such that it can be used within
the replace text.<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>[^,]</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">A character set that matches everything EXCEPT a comma.
In a comma delimited file, this is how you implement short matching so the
match ends on the first comma.<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right"><b><tt>*</tt><br>
      </b></td>
      <td valign="top"><br>
      </td>
      <td valign="top">An enumerator indicating zero or more of the character
or character set that preceded it. In this case, it means zero or more non-commas.
Those zero or more non-commas correspond to the first field in the line.<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\)</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Ends the first group.<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right"><b><tt>,</tt><br>
      </b></td>
      <td valign="top"><br>
      </td>
      <td valign="top">Matches a comma, which is the field delimiter in a comma delimited file.<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\(</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Begins the second group<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>[^,]*</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Zero or more non-commas corresponding to the second field<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\)</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Ends the second group<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right"><b><tt>,</tt><br>
      </b></td>
      <td valign="top"><br>
      </td>
      <td valign="top">Matches the comma that separates the second field from the third field<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\(</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Begins the third group</td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>.*</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Zero or more characters of any type. This represents
the rest of the line. Because the only fields you're modifying are the first
and second, you can group the third, fourth, ... fields together into one
group -- the third group.<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\)</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Ends the third group<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right"><b>/<br>
      </b></td>
      <td valign="top"><br>
      </td>
      <td valign="top">Ends the search expression and begins the replace expression<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\2</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">The text that was matched by the second group of the
search expression, which, in fact, was the second field, which we are now
putting first<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right"><b><tt>,</tt><br>
      </b></td>
      <td valign="top"><br>
      </td>
      <td valign="top">Literal comma to separate the first and second fields in the replaced text.<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\1</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Text matched by the first group in the search expression, which we are now putting second.<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>,</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Literal comma to separate the new second field from the third<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\3</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Text matched by the third group in the search expression, which in fact represented all fields after the first two<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>/</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Ends the replace expression<br>
      </td>
    </tr>
  </tbody>
</table>


<br>


Study the preceding information. Once you understand the preceding, you understand
most of what it takes to use search information in the replace expression.
Here's another example -- a titlecase converter:<br>


<pre><b>:%s/\&lt;\(.\)\([^[:space:][:punct:]]*\)\&gt;/\u\1\2/g</b><b><tt><br></tt></b></pre>


You might use this in a VI based book outline in order to titlecase all headings
for later use as parts, sections, subsections, etc. Let's quickly analyze:<br>


<table cellpadding="3">


  <tbody>
    <tr>
      <td valign="top" align="right">
      <pre><b>:s</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Substitute on every line<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>/</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Start search expression<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\&lt;</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Matches position at beginning of word (between the
space or punctuation preceding the word and the first alphanumeric of the
word<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\(.\)</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Group containing the first character of the word<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\(</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Begin second group<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>[^[:space:][:punct:]]*</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Series
(zero or more) characters that are neither whitespace nor punctuation. This
makes up the remainder of the word. This is discussed further in the <a href="http://www.troubleshooters.com/lpm/200212/200212.htm#Short_Matching">Short Matching</a> section of this article.<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\)</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">End second group<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\&gt;</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Matches position at end of word (between the last alphanumeric of the word and the punctuation or space following the word)<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>/</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Ends the search expression and begins the replace expression<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\u</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Means the next character or metacharacter will be capitalized<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\1</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">The text that matched the first group of the search
expression. In this case that means the first character of the word, which
due to the \u before it in the replace expression, means it's capitalized.<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\2</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">The text that matched the second group of the search expression. In this case that means the remainder of the word.<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>/</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Ends the replace expression<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>g</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Means global, meaning that you don't quit on the first
match. This is what enables this title case converter to work on every word
of the line.<br>
      </td>
    </tr>
  </tbody>
</table>


<br>



Once again, review the preceding, especially noting the use of \&lt; and \&gt; to delineate words, the use of <br>


<tt>[^[:space:][:punct:]]*</tt> to represent the remainder of a word, and the use of \u to uppercase the next item in the replace expression.<br>


<br>


The following table lists several pieces of syntax used when you use matched text in the replacement:<br>


<table cellpadding="2" cellspacing="2" border="1">


  <tbody>
    <tr>
      <td valign="top" align="right">
      <pre><b>\(.....\)</b></pre>
      </td>
      <td valign="top">Delineates
a group. Whatever matches the expression inside the \( and \) is remembered
and available in the replace expression. In this example, any series of 5
characters matches the expression inside the \( and \).</td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\1</b></pre>
      </td>
      <td valign="top">Used inside the replace expression, this is replaced by the text matched by the first group in the search expression.<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\2<br></b></pre>
      </td>
      <td valign="top">Used inside the replace expression, this is replaced
by the text matched by the second group in the search expression. Likewise
\3 is replaced by the text matched by the third group, \4 by the text matched
by the 4th group, all the way up to \9.</td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\u</b></pre>
      </td>
      <td valign="top">Used in the search expression, this matches any upper
case letter. Used in the replace expression, this uppercases the next single
item in the replacement expression.<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\l</b></pre>
      </td>
      <td valign="top">Used in the search expression, this matches any lower case letter. Used in
the replace expression, this lowercases the next single item in the replacement
expression.</td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\U</b></pre>
      </td>
      <td valign="top">Used in the search expression, this matches any character that IS NOT an upper case letter. Used in
the replace expression, this uppercases the remainder of the replacement
expression. However, a later \L in the replace expression will "turn off" the \U at the point of appearance of the \L.</td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\L</b></pre>
      </td>
      <td valign="top">Used in the search expression, this matches any character that IS NOT a lower case letter. Used in
the replace expression, this lowercases the remainder of the replacement
expression. However, a later \U in the replace expression will "turn off" the \L at the point of appearance of the \U.</td>
    </tr>
  </tbody>
</table>


<br>


Using matched text is one of VI's most powerful features. Many other word
processors require you to write a macro in order to accomplish similar things.
Of course you could write the same types of macros in VI, but once you get
used to regular expressions it takes only 1/4 to 1/10 the time.<br>


<h2><a name="Short_Matching"></a>Short Matching<br>
</h2>



Consider the following sentence:<br>


<br>


<i>I will roll the wheel from the whalebelly to the well.</i><br>


<br>


Let's say you want to find every string that begins with w and ends with
ll, replacing it with XXX. You want the line changed to the following:<br>


<br>


<i>I XXX roll the wheel from the XXXy to the XXX.</i><br>


<br>


How bout this:<br>


<pre>s/w.*ll/XXX/g<br></pre>


The <tt>g</tt> on the end means global, meaning keep finding and replacing
after finding the first one. Unfortunately, the preceding regex will instead
produce the following:<br>


<br>


<i>I XXX.<br>
</i><br>

What happened? Unless told otherwise, regular expressions match as
much as possible. So it found the first w (the one in will), and the last
ll (the one in well), and replaced them, and everything in between, with
XXX. How would you make the matches as short as possible? &nbsp;Some environments,
such as Perl, have special modifiers enabling enumerators to match as short
as possible. This isn't available in many VI &nbsp;implementations.<br>


<br>


What's needed is a way to limit the scope of the enumerator. Consider the following:<br>


<pre>:s/w[^l]*ll/XXX/g<br></pre>



This is much closer, producing the following:<br>


<br>


<i>I XXX roll the wheel from the whalebelly to the XXX.</i><br>


<br>


It found "will" and "well", but missed "whalebell". What happened is the
first "l" in "whalebelly" reset the search, so that the search went back
to searching for "w", moving all the way to the last word of the line.<br>


<br>


If we can agree that we should match long on a per word basis (in other words,
"wellwall" will be replaced by XXX and not XXXXXX), we can limit by word
boundaries instead of the "l" character:<br>


<pre>:s/w[^[:space:][:punct:]]*ll/XXX/g<br></pre>


The preceding produces the desired:<br>


<br>


<i>I XXX roll the wheel from the XXXy to the XXX.</i><br>


<br>


If you want full short matching ("wellwall" replaced by XXXXXX), you need to use advanced techniques involving groups.<br>
<h5>
Steve Litt is the author of <a href="http://www.troubleshooters.com/bookstore/rl.htm">Rapid Learning:
Secret Weapon of the Successful Technologist</a> . He can be reached at
<a href="http://www.troubleshooters.com/email_steve_litt.htm">Steve Litt's email address</a>.</h5>










<h1><a name="_Advanced_Searches_with_Groups"></a>Advanced Searches with Groups</h1>


<h5>By Steve Litt</h5>


I wouldn't blame you for skipping this article. It's brutal, and for 90%
of your editing activities you won't need its power. Indeed, what you can
do with groups in a regular expression would be difficult for a good programmer
using C (unless he was using regular expressions).<br>


<br>


Let's say you want to find a phone number. Look at all the ways phone numbers can be written:<br>


<ul>


  <li>(800)555-1212</li>
  <li>(800) 555-1212</li>
  <li>(800)-555-1212</li>
  <li>800-555-1212</li>
  <li>555-1212</li>
</ul>


These don't include putting 1- in front -- it can be done but I want to keep this
example understandable. How can you write a single search
expression to find all of these different methods?<br>


<br>


The first thing to notice is that everything except the area code is simple:<br>


<pre>/\d\{3}-\d\{4}<br></pre>


As things get hairy, it's important to note that the last 8 characters are a "gimme".<br>


<br>


If you notice, either you have an area code plus optional dash or space between
it and the exchange, or you don't. So you make a group to hold the area code,
its parens or lack thereof, and option dash or space. We already discussed
groups in the <a href="http://www.troubleshooters.com/lpm/200212/200212.htm#Using_Matched_Text_as_Replacement_Text">Using Matched Text as Replacement Text</a>
section of this article, where we used it to capture text for later use in
the replace expression. The more powerful use is to create incredibly versatile
searches, such as detecting all these different phone number formats.<br>


<br>


So anyway, we can start by dreaming of a group containing area code, optional
parens, and an optional trailing separator, and prepending it onto the search
for the exchange and 4 digit number:<br>


<pre>/\(area_code_group\)\?\d\{3}-\d\{4}<br></pre>


Following in the footsteps of programmers since the dawn of time, let's simply
forget about the last 7 digits and concentrate on the area code group.<br>


<br>


One thing you know is the area code has it has parentheses or it doesn't.
The other punctuation depends on whether it has parentheses. If it has parentheses
you look for this:<br>


<pre>/(\d\{3})[- ]\?</pre>


That's an opening paren, exactly three digits, a closing paren, and one or
zero iterations of either a space or a dash. Obviously if there are zero
iterations it matches a string where the paren buts up against the telephone
exchange.<br>


<br>


If there are no parens, it's even simpler because you must have a dash after the area code. <br>


<pre>\d\{3}-</pre>


We'll use the \| operator to represent alternatives. In truth I don't know
whether many VI implementations offer the \| operator, but I know that Vim
does. By the way, in case you haven't noticed, Vim is my favorite VI implementation,
though I like all VI's. Anyway, here's the first step in representing the
area code:<br>


<pre>/(\d\{3})[- ]\?\|\d\{3}-&nbsp; </pre>


This matches area codes with or without parens. Remembering phone numbers
can have one or zero area codes, together with the area code's parens and
optional trailing dash or space, we put that in a group that can happen zero
or one time, and append the regex for the last 7 digits of the phone number:<br>


<pre><b><font size="+1"><font color="#330033">/</font><font color="#330033">\(</font><font color="#330033">(\d\{3})[- ]\?</font><font color="#330033">\|</font><font color="#330033">\d\{3}-</font><font color="#330033">\)</font><font color="#330033">\?</font><font color="#993399"><font color="#330033">\d\{3}-\d\{4}</font></font></font></b></pre>


To make this clearer, let's color code it:<br>


<pre><font size="+1"><b>/<font color="#cc0000">\(</font><font color="#006600">(\d\{3})[- ]\?</font><font color="#ff6600">\|</font><font color="#000099">\d\{3}-</font><font color="#cc0000">\)</font><font color="#339999">\?</font><font color="#993399">\d\{3}-\d\{4}</font></b></font><br></pre>


<br>


<table cellpadding="2" cellspacing="2" border="1">


  <tbody>
    <tr>
      <td valign="middle" align="right" bgcolor="#cccccc"><b>Color<br>
      </b></td>
      <td valign="middle" align="center" bgcolor="#cccccc">
      <pre><b>Regex<br></b></pre>
      </td>
      <td valign="middle" bgcolor="#cccccc"><b>Explanation<br>
      </b></td>
    </tr>
    <tr>
      <td valign="middle" align="right"><b><font color="#cc0000">red<br>
      </font></b></td>
      <td valign="middle" align="center">
      <pre><b><font color="#cc0000">\( to \)<br></font></b></pre>
      </td>
      <td valign="middle"><b><font color="#cc0000">Group &nbsp;consisting of all area code and trailing punctuation alternatives</font><br>
      </b></td>
    </tr>
    <tr>
      <td valign="middle" align="right"><b><font color="#00cccc">turquoise<br>
      </font></b></td>
      <td valign="middle" align="center">
      <pre><b><font color="#00cccc">\?<br></font></b></pre>
      </td>
      <td valign="middle"><b><font color="#00cccc">Signifies 0 or 1 instances of the area code group.<br>
      </font></b></td>
    </tr>
    <tr>
      <td valign="middle" align="right"><b><font color="#993399">magenta</font></b></td>
      <td valign="middle" align="center">
      <pre><b><font size="+1"><font color="#993399">\d\{3}-\d\{4}</font></font></b></pre>
      </td>
      <td valign="middle"><b><font color="#993399">Phone number without area code</font></b></td>
    </tr>
    <tr>
      <td valign="middle" align="right"><b><font color="#ff6600">orange</font></b></td>
      <td valign="middle" align="center">
      <pre><b><font size="+1"><font color="#ff6600">\|</font></font></b></pre>
      </td>
      <td valign="middle"><b><font color="#ff6600">Signifies that the element on its left and on its right are either/or alternatives</font></b></td>
    </tr>
    <tr>
      <td valign="middle" align="right"><b><font color="#006600">green</font></b></td>
      <td valign="middle" align="center">
      <pre><b><font size="+1"><font color="#006600">(\d\{3})[- ]\?</font></font></b></pre>
      </td>
      <td valign="middle"><b><font color="#006600">Structure (with options) of area code with parens</font></b></td>
    </tr>
    <tr>
      <td valign="middle" align="right"><b><font color="#000099">blue</font></b></td>
      <td valign="middle" align="center">
      <pre><b><font size="+1"><font color="#000099">\d\{3}-</font></font></b></pre>
      </td>
      <td valign="middle"><b><font color="#000099">Structure of the area code without parens</font><br>
      </b></td>
    </tr>
  </tbody>
</table>


<br>


Groups can be nested, and nested, and nested some more. In VI implementations
that allow it, alternative groups can be specified with the \| operator (or
possibly a different operator in a different VI implementation).<br>


<br>


If your head doesn't hurt too badly, for extra credit try to make a substitute
expression that converts all these phone number formats to a single format.
I can't do it in a single step, but I can do it in a 2 step process. The
first substitute finds all valid phone numbers and surrounds them with <tt>pho_</tt> on one side and <tt>_ohp</tt>
on the other. The second finds such surrounded strings and picks off the
digits. This 2 stage approach frees the second replace from worrying about
punctuation, or mixing detection and validation with substitution.<br>


<br>


To do this, step 1 must surround the ENTIRE search expression with \( and
\) to make it a single group, and place it in a substitute:<br>


<br>


<pre><b>:%s/\(\((\d\{3})[- ]\?\|\d\{3}-\)\?\d\{3}-\d\{4}\)/pho_\1_ohp/</b></pre>


Step 2 formats all resulting strings that include area codes in a standard format:<br>


<pre><b>:%s/pho_\D*\(\d\d\d\)\D*\(\d\d\d-\d\d\d\d\)_ohp/(\1)-\2/</b><br></pre>
You'll notice that all phone numbers that didn't include an area code were
not converted. To convert them you need to run a second, much simpler substitute
command.<br>
<br>


I think you know where I'm going with this. If we can recognize all forms
of phone numbers, and we can also remember matched text for use in the replace
expression, then it's pretty obvious we can make a regular expression to
"standardize" phone numbers. In this case we need to surround the digits
of the phone number with slash parens. It's made more difficult because those
slash parens are nested in a major group and are alternatives. <br>


<h2>Summary</h2>

Regular expressions are huge. Master them and you can do
in 5 minutes what others take hours to do. One of the most powerful regular
expression techniques is the use of groups. By using groups, you can search
for various alternatives, and for phrases that may or may not be there or
may be repeated. Groups can be nested.<br>






<h5>
Steve Litt is the author of <a href="http://www.troubleshooters.com/bookstore/rl.htm">Rapid Learning:
Secret Weapon of the Successful Technologist</a> . He can be reached at
<a href="http://www.troubleshooters.com/email_steve_litt.htm">Steve Litt's email address</a>
.</h5>






<h1><a name="_Registers_Cut_and_Paste"></a>Registers, Cut and Paste</h1>





<h5>By Steve Litt</h5>

The most significant factor in a software developer's
success is his or her design process. Next comes his or her debugging process,
including use of tools such as debuggers. Obviously, a good memory or skillful
use of reference material play an important part also.<br>


<br>


And for those of us without total recall, cut and paste plays a vital role
in our software development productivity. The ability to copy documentation
and paste it into our code, to copy a function declaration to the code that
uses the function, and many other cut and paste tasks speed our productivity
immensely.<br>


<br>


VI's cut and paste is richer than most other editors because of VI's vast
array of registers. A register is simply a place to store text.<br>


<br>


The simplest cut and paste operation is to delete a single line and paste it elsewhere. The line delete is accomplished by the <tt>dd</tt> key sequence, which deletes the current line and places it in the default register, the <tt>""</tt> register. You can then move to another location, and press the <tt>p</tt> key, which pastes the contents of the <tt>""</tt> register below the current line.<br>


<br>


If you had wanted to copy the line instead of cut it, you could have used the <tt>yy</tt> keystroke sequence to "yank" the line into the <tt>""</tt> register, and then moved and used the <tt>p</tt> keystroke to paste it below the current line.<br>


<br>


By the way, if you want to paste above the current line instead of below it, you'd use the <tt>P</tt> keystroke instead of the <tt>p</tt> keystroke.<br>


<br>


Anyway, the <tt>""</tt> register always contains the text of your last deletion
or yank, meaning it will quickly be be overwritten by the next delete or
yank. To save a delete or yank, delete it or yank it into a specific register.
For instance, to delete the current line and save it in the <tt>"b</tt> register, use the <tt>"bdd</tt> keystroke sequence. To yank (copy without delete) a line into register <tt>"c</tt> use the <tt>"cyy</tt>
keystroke sequence. In general, you save any deletion or yank to a named
register by preceding the delete or yank command with a doublequote and the
register letter.<br>


<br>


To paste from a specific register, prepend a doublequote and the register letter to the paste command. Thus <tt>"bp</tt> pastes the contents of the <tt>"b</tt> register after the current position, while <tt>"eP</tt> pastes the contents of the <tt>"e</tt> register before the current position.<br>


<br>


To see a list of all the registers and their contents, use the <tt>:reg</tt> command.<br>


<h2>The System Clipboard Register</h2>


Some VI implementations have a special register whose contents are those
of the system clipboard. Vim is one such implementation, and in Vim that
register is the <tt>"*</tt> register. So in Linux, if you want to paste part
of a browser hosted help file into the file you're editing, highlight the
material in the browser, switch to Vim and type the <tt>"*p</tt> keystroke sequence.<br>


<br>


Likewise, to move a line from Vim to Mozilla Composer, press <tt>"*yy</tt>,
switch to Mozilla Composer, press the middle mouse button, and watch the
line appear in Mozilla Composer. A single line isn't particularly impressive,
but with techniques discussed later in this article you can copy entire subroutines.<br>


<h2>Various Delete and Yank Commands<br>
</h2>


Sometimes you want to delete only part of a line, instead of the complete
line. To delete to the end of the current word, you'd use the <tt>dw</tt> keystroke sequence. To copy the remainder of the current word you'd use the <tt>yw</tt> keystroke sequence. When you delete or yank a line fragment, the <tt>p</tt> and <tt>P</tt> commands act differently, in that they paste before or after the current character instead of the current line.<br>


<br>


In general, deletion commands have corresponding yank commands. The following table lists several such commands:<br>


<br>


<table cellpadding="2" cellspacing="2" border="1">


  <tbody>
    <tr>
      <td valign="top" bgcolor="#cccccc">Text to copy or cut<br>

      </td>
      <td valign="top" bgcolor="#cccccc">Delete<br>

      </td>
      <td valign="top" bgcolor="#cccccc">Yank<br>

      </td>
      <td valign="top" bgcolor="#cccccc">Char or Line<br>

      </td>
    </tr>
    <tr>
      <td valign="top">Current line<br>
      </td>
      <td valign="top">dd<br>
      </td>
      <td valign="top">yy<br>
      </td>
      <td valign="top">L<br>
      </td>
    </tr>
    <tr>
      <td valign="top">Current plus next 2 lines<br>
      </td>
      <td valign="top">3dd<br>
      </td>
      <td valign="top">3yy<br>
      </td>
      <td valign="top">L<br>
      </td>
    </tr>
    <tr>
      <td valign="top">Current word<br>
      </td>
      <td valign="top">dw<br>
      </td>
      <td valign="top">yw<br>
      </td>
      <td valign="top">C<br>
      </td>
    </tr>
    <tr>
      <td valign="top">Current plus next 2 words<br>
      </td>
      <td valign="top">2dw or d2w<br>
      </td>
      <td valign="top">2yw or y2w<br>
      </td>
      <td valign="top">C<br>
      </td>
    </tr>
    <tr>
      <td valign="top">Current plus previous 2 words<br>
      </td>
      <td valign="top">2db<br>
      </td>
      <td valign="top">2yb<br>
      </td>
      <td valign="top">C<br>
      </td>
    </tr>
    <tr>
      <td valign="top">Current char to end of line<br>
      </td>
      <td valign="top">D or d$<br>
      </td>
      <td valign="top">y$<br>
      </td>
      <td valign="top">C<br>
      </td>
    </tr>
    <tr>
      <td valign="top">Preceding char to beginning of line<br>
      </td>
      <td valign="top">d0<br>
      </td>
      <td valign="top">y0<br>
      </td>
      <td valign="top">C<br>
      </td>
    </tr>
    <tr>
      <td valign="top">Character under cursor<br>
      </td>
      <td valign="top">x<br>
      </td>
      <td valign="top">&nbsp;<br>
      </td>
      <td valign="top">C<br>
      </td>
    </tr>
    <tr>
      <td valign="top">Character before cursor<br>
      </td>
      <td valign="top">X<br>
      </td>
      <td valign="top">&nbsp;<br>
      </td>
      <td valign="top">C<br>
      </td>
    </tr>
    <tr>
      <td valign="top">Remainder of paragraph<br>
      </td>
      <td valign="top">d}<br>
      </td>
      <td valign="top">y}<br>
      </td>
      <td valign="top">C<br>
      </td>
    </tr>
    <tr>
      <td valign="top">Earlier part of paragraph<br>
      </td>
      <td valign="top">d{<br>
      </td>
      <td valign="top">y{<br>
      </td>
      <td valign="top">C<br>
      </td>
    </tr>
    <tr>
      <td valign="top">Current char to start of <tt>searchtext</tt><br>
      </td>
      <td valign="top">d/searchtext<br>
      </td>
      <td valign="top">y/searchtext<br>
      </td>
      <td valign="top">C<br>
      </td>
    </tr>
    <tr>
      <td valign="top">Preceding char to start of  <tt>searchtext</tt></td>
      <td valign="top">d?searchtext</td>
      <td valign="top">y?searchtext</td>
      <td valign="top">C<br>
      </td>
    </tr>
    <tr>
      <td valign="top">To end of sentence (not counting the period)<br>
      </td>
      <td valign="top">d\/.<br>
      </td>
      <td valign="top">y\/.<br>
      </td>
      <td valign="top">C<br>
      </td>
    </tr>
  </tbody>
</table>


<br>


Notice in the preceding that many of the commands are composed by appending a motion command to the end of the &nbsp;<tt>d</tt> or <tt>y</tt>. The motion command can be a built in one like <tt>w</tt> or <tt>}</tt>, or it can be a search. Either way, all the characters traversed in the motion are deleted or yanked.<br>


<h2>WYSIWYG Cut and Paste</h2>


Many VI implementations, including Vim, allow visual mode highlighting, in which case simply pressing the <tt>d</tt> or <tt>y</tt>
key will delete or yank the highlighted text. For instance, in Vim you can
highlight line by line by pressing &nbsp;the <tt>V</tt> key and then moving with motion commands
such as <tt>j</tt>, <tt>k</tt>, <tt>}</tt> or a search. You can start&nbsp; highlighting character by character with the <tt>v</tt> key. <br>


<br>


And in Vim, you can start rectangular highlighting with the Ctrl+v keystroke
combination. This extremely powerful capability allows you to switch fields
around in a fixed length sequential record file. You can also build up such
a file field by field by typing a field's contents on each line, and then
rectangular cut and paste that onto the end of the preceding fields.<br>


<br>


Rectangular delete is excellent for deleting the first several characters
from several lines or all lines in the file, or for deleting past a certain
column.<br>


<h2>Summary</h2>VI offers a wide variety of delete, cut, copy and paste techniques
that are keyboard easy. The practitioner knowing the techniques listed in
this article will be able to edit quickly. Your VI implementation will probably
have many additional techniques not discussed in this article, giving you
the opportunity to be even faster.<br>


<br>


In VI the concepts of "cut" and "delete" are identical -- deleting text always sends it to the <tt>""</tt>
register, which could be thought of as "the VI clipboard". This concept is
called "delete" in VI, and is implemented with various keystroke sequences
starting with <tt>d</tt>. The concept of "copy" is called "yank" in VI, and is typically implemented with a various keystroke sequences starting with <tt>y</tt>.<br>


<br>


Deletes and yanks can either be character by character or line by line. The distinction is important when pasting.<br>


<br>


VI has two paste commands, <tt>p</tt> and <tt>P</tt>. The lower case paste
command pastes after the current position, while the upper case version pastes
before the current position. If the previously deleted or yanked material
was line by line, the pasted material goes in new lines opened either after
(<tt>p</tt>) or before (<tt>P</tt>) the current line. If the previously deleted
or yanked material was character by character, the new material starts on
the current line either after (<tt>p</tt>) or before (<tt>P</tt>) the character over which the cursor resides.<br>


<h5>Steve Litt is the author of <a href="http://www.troubleshooters.com/bookstore/rl.htm">Rapid Learning:
Secret Weapon of the Successful Technologist</a> . He can be reached at
<a href="http://www.troubleshooters.com/email_steve_litt.htm">Steve Litt's email address</a>
.</h5>




<h1>
<a name="_Macros_and_Scripts"></a>Macros and Scripts</h1>






<h5>
By Steve Litt</h5>

A macro is a sequence of keystrokes to accomplish
a task. A script is a sequence of commands to accomplish a task. In Scripts
are usually EX mode commands (the kind of commands that start with a colon
(:)), while macros are usually command mode commands such as <tt>dd</tt>, <tt>i</tt>, and typed in text.&nbsp; Macros are stored in registers, while scripts are stored in files. Macros are run by typing <tt>@</tt> and then the register letter, such as <tt>@b</tt>. Scripts are run by typing <tt>:source</tt> followed by the filename of the file containing the macro:<br>


<pre>:source myscriptfile</pre>


Macros are recorded by pressing the <tt>q</tt> key followed by a letter representing the register in which to store the macro. The recording process is ended when a second <tt>q</tt> is pressed <i>while in command mode</i>.
So, just like so many other editors, VI enables you to construct a macro
interactively in real time, and then later play the macro back. Macros assume
even more power when you include a multiple by prepending the number of times
to do it. For instance, if you wanted to append the word "Done" to 10 lines,
you could create the following macro in register b:<br>


<pre>A Done^[j0</pre>


The preceding appends the word <tt>Done</tt> to the end of the line, types an Esc
character to &nbsp;get back into command mode, goes to the next line and
then goes to the beginning of the line. So you've appended "Done" and then
gone to the beginning of the next line. If you then the type <tt>10@b</tt> keystroke sequence, the current line and the next 9 have the word "Done" appended to them. Better yet, if you type <tt>1000@b</tt>
and there are only 20 lines in the file, the current line and every succeeding
line is appended, but at end of file the other 980 iterations are ignored.<br>


<br>


Macros are the way editors without regular expressions do much of their magic,
and in fact, VI can do the same type of magic with macros.<br>


<br>


Let's review some distinctions between macros and scripts:<br>


<br>


<table cellpadding="2" cellspacing="2" border="1" width="100%">


  <tbody>
    <tr>
      <td valign="top" bgcolor="#cccccc">Property<br>
      </td>
      <td valign="top" bgcolor="#cccccc">Macro<br>
      </td>
      <td valign="top" bgcolor="#cccccc">Script<br>
      </td>
      
    </tr>
    <tr>
      <td valign="top">What it is<br>
      </td>
      <td valign="top">A series of command mode character commands<br>
      </td>
      <td valign="top">A series of EX mode colon commands<br>
      </td>
      
    </tr>
    <tr>
      <td valign="top">Where it's stored<br>
      </td>
      <td valign="top">In a register<br>
      </td>
      <td valign="top">In a file<br>
      </td>
      
    </tr>
    <tr>
      <td valign="top">How it's recorded<br>
      </td>
      <td valign="top">Interactively following the q command<br>
      </td>
      <td valign="top">Programatically by a text editor<br>
      </td>
      
    </tr>
    <tr>
      <td valign="top">How recording is stopped<br>
      </td>
      <td valign="top">A q command within command mode<br>
      </td>
      <td valign="top">n/a<br>
      </td>
      
    </tr>
    <tr>
      <td valign="top">How it's run<br>
      </td>
      <td valign="top">@ followed by the register letter<br>
      </td>
      <td valign="top">:source followed by the filename<br>
      </td>
      
    </tr>
    <tr>
      <td valign="top">How it's run multiple times<br>
      </td>
      <td valign="top">Precede the @ with a multiplier<br>
      </td>
      <td valign="top">n/a<br>
      </td>
      
    </tr>
    <tr>
      <td valign="top">How to append to it<br>
      </td>
      <td valign="top">Typing q followed by the upper case register letter appends to the existing register macro.<br>
      </td>
      <td valign="top">In a text editor.<br>
      </td>
      
    </tr>
    <tr>
      <td valign="top">How to edit it<br>
      </td>
      <td valign="top">
      <ol>
        <li>For example, assume register b contains the macro<br>
        </li>
        <li>Open a blank line in VI</li>
        <li><tt>"bP</tt> to insert the register b macro procedures on the line</li>
        <li>Edit the line as desired</li>
        <li>Move to the beginning of the line<br>
        </li>
        <li>"bD to delete the line to register b<br>
        </li>
      </ol>
      </td>
      <td valign="top">In a text editor.</td>
      
    </tr>
    <tr>
      <td valign="top">Running one from the other<br>
      </td>
      <td valign="top">Include <tt>:source filename&lt;CR&gt;</tt> in the macro while in command mode<br>
      </td>
      <td valign="top">:normal @b<br>
(see note)<br>
      </td>
      
    </tr>
  </tbody>
</table>


<table cellpadding="2" cellspacing="2" border="1" width="40%" align="right">
  <tbody>
    <tr>
      <td valign="top">
      <div align="center"><font size="+1"><b>NOTE</b></font><br>
      </div>
      <br>
The <tt>:normal @b</tt> syntax works only in Vim, and possibly a few other
VI implementations. It doesn't work in the "standard" VI from the UNIX world.<br>
      </td>
    </tr>
  </tbody>
</table>
<br>


<h2>Scripts</h2>


At the dawn of computerized civilization, before the invention of the VI
full screen editor, there was a line editor called EX. EX was incredibly
powerful, but being a line editor with a command line, it was spectacularly
unproductive. Then somebody built VI as a full-screen front end to EX. The
authors of VI left several ways to access the underlying EX. Some of the
more common ones are:<br>


<ol>


  <li>You can run a single EX command by preceding it with the colon character</li>
  <li>You can put a series of EX commands in a script and run it with the <tt>:source</tt> command.<br>
  </li>
  <li>You can go into EX mode by running VI with the <tt>-e</tt> option.</li>
</ol>


#3 is rarely used today and won't be discussed. #1 has been mentioned frequently
so far in this magazine. #2 is the subject of this section.<br>

<br>

The following is a very abbreviated list of EX commands you can use in scripts:<br>

<table cellpadding="2" cellspacing="2" border="1">

  <tbody>
    <tr>
      <td valign="top" bgcolor="#cccccc">
      <pre>COMMAND</pre>
      </td>
      <td valign="top" bgcolor="#cccccc">EFFECT<br>
      </td>
    </tr>
    <tr>
      <td valign="top">
      <pre><b>:q</b></pre>
      </td>
      <td valign="top">Quit VI<br>
      </td>
    </tr>
    <tr>
      <td valign="top">
      <pre><b>:q!</b></pre>
      </td>
      <td valign="top">Quit even if there are unsaved changes<br>
      </td>
    </tr>
    <tr>
      <td valign="top">
      <pre><b>:e filename</b></pre>
      </td>
      <td valign="top">Edit a different file<br>
      </td>
    </tr>
    <tr>
      <td valign="top">
      <pre><b>:e! filename</b></pre>
      </td>
      <td valign="top">Edit a different file even if this one has unsaved changes<br>
      </td>
    </tr>
    <tr>
      <td valign="top">
      <pre><b>:e!</b></pre>
      </td>
      <td valign="top">Edit the disk version of this file, even if there
are unsaved changes in the memory version. &nbsp;This is basically a revert
command.<br>
      </td>
    </tr>
    <tr>
      <td valign="top">
      <pre><b>:bn</b></pre>
      </td>
      <td valign="top">Go to the next buffer. For each file opened with an
:e command there is a buffer, so you can switch from buffer to buffer, as
long as the current one is saved. This command wraps, meaning once you pass the last buffer, you go back to the first one<br>
      </td>
    </tr>
    <tr>
      <td valign="top">
      <pre><b>:bp</b></pre>
      </td>
      <td valign="top">Go to the previous buffer. For each file opened with an :e command there is a
buffer, so you can switch from buffer to buffer, as long as the current one
is saved. This command wraps, meaning once you pass the first buffer, you go back to the last (highest numbered) one</td>
    </tr>
    <tr>
      <td valign="top">
      <pre><b>:b3</b></pre>
      </td>
      <td valign="top">Go
to buffer # 3. Obviously you can put any number in there to go to its corresponding
buffer. If you put a number higher than the last buffer, you get an error
message.<br>
      </td>
    </tr>
    <tr>
      <td valign="top">
      <pre><b>:bl</b></pre>
      </td>
      <td valign="top">Go to the last (highest number) in the buffer list.<br>
      </td>
    </tr>
    <tr>
      <td valign="top">
      <pre><b>:bd</b></pre>
      </td>
      <td valign="top">Delete the current buffer, so the file is no longer in memory (but it's still on disk).
If the buffer deleted is #5, the former #6 becomes #5, and all higher numbered
buffers are renumbered to be one less than their former values, so there
are no "holes" in the list of buffers.<br>
      </td>
    </tr>
    <tr>
      <td valign="top">
      <pre><b>:buffers</b></pre>
      </td>
      <td valign="top">Lists all buffers -- by number, with filename<br>
      </td>
    </tr>
    <tr>
      <td valign="top">
      <pre><b>:/search</b></pre>
      </td>
      <td valign="top">Search forward and goto the first matching line<br>
      </td>
    </tr>
    <tr>
      <td valign="top">
      <pre><b>:?search</b></pre>
      </td>
      <td valign="top">Search backward and goto the first matching line<br>
      </td>
    </tr>
    <tr>
      <td valign="top">
      <pre><b>:s/search/repl/</b></pre>
      </td>
      <td valign="top">The substitute command. Can be used with ranges as discussed <a href="http://www.troubleshooters.com/lpm/200212/200212.htm#Ranges">Ranges</a> section of the <a href="http://www.troubleshooters.com/lpm/200212/200212.htm#_Elementary_Search_and_Replace_and_Global_Commands">Search and Replace: Substitute and Global Commands</a> article.</td>
    </tr>
    <tr>
      <td valign="top">
      <pre><b>:g/search/cmd</b></pre>
      </td>
      <td valign="top">The global command. Can be used with ranges as discussed <a href="http://www.troubleshooters.com/lpm/200212/.htm#Ranges">Ranges</a> section of the <a href="http://www.troubleshooters.com/lpm/200212/200212.htm#_Elementary_Search_and_Replace_and_Global_Commands">Search and Replace: Substitute and Global Commands</a> article.</td>
    </tr>
    <tr>
      <td valign="top">
      <pre><b>:set</b></pre>
      </td>
      <td valign="top">Sets a VI property<br>
      </td>
    </tr>
    <tr>
      <td valign="top">
      <pre><b>:let x = 1</b></pre>
      </td>
      <td valign="top">Variable assignment<br>
      </td>
    </tr>
    <tr>
      <td valign="top">
      <pre><b>:d</b></pre>
      </td>
      <td valign="top">Delete line. Can be used with ranges as discussed <a href="http://www.troubleshooters.com/lpm/200212/200212.htm#Ranges">Ranges</a> section of the <a href="http://www.troubleshooters.com/lpm/200212/200212.htm#_Elementary_Search_and_Replace_and_Global_Commands">Search and Replace: Substitute and Global Commands</a> article.</td>
    </tr>
    <tr>
      <td valign="top">:put<br>
      </td>
      <td valign="top">Paste the content from the last delete or yank. Can be used with an optional line number and an optional register. See <tt>:h :put</tt> for details.<br>
      </td>
    </tr>
<tr>
      <td valign="top">
      <pre><b>:!sysCmd</b></pre>
      </td>
      <td valign="top">Filters lines through an operating system command. Can be used with ranges as discussed <a href="http://www.troubleshooters.com/lpm/200212/200212.htm#Ranges">Ranges</a> section of the <a href="http://www.troubleshooters.com/lpm/200212/200212.htm#_Elementary_Search_and_Replace_and_Global_Commands">Search and Replace: Substitute and Global Commands</a> article. The lines in the range are sent to the command, and are replaced by the output of the command. Common examples:<br>
      <table cellpadding="2" cellspacing="2" border="1">
        <tbody>
          <tr>
            <td valign="top" bgcolor="#cccccc">sysCmd<br>
            </td>
            <td valign="top" bgcolor="#cccccc">RESULT<br>
            </td>
          </tr>
          <tr>
            <td valign="top">:%sort<br>
            </td>
            <td valign="top">Sort the file<br>
            </td>
          </tr>
          <tr>
            <td valign="top">:%sort -n<br>
            </td>
            <td valign="top">Sort file numerically<br>
            </td>
          </tr>
          <tr>
            <td valign="top">:%sort -u<br>
            </td>
            <td valign="top">Sort unique -- delete dups<br>
            </td>
          </tr>
          <tr>
            <td valign="top">:cat -n<br>
            </td>
            <td valign="top">Prepend line numbers to each line<br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
      </td>
    </tr>
    <tr>
      <td valign="top">
      <pre><b>:r filename</b></pre>
      </td>
      <td valign="top">Inserts the contents of <tt>filename</tt> below the current line.<br>
      </td>
    </tr>
    <tr>
      <td valign="top">
      <pre><b>:r!sysCmd</b></pre>
      </td>
      <td valign="top">Inserts the output of sysCmd below the current line. A few common examples:<br>
      <table cellpadding="2" cellspacing="2" border="1">
        <tbody>
          <tr>
            <td valign="top" bgcolor="#cccccc">sysCmd<br>
            </td>
            <td valign="top" bgcolor="#cccccc">RESULT<br>
            </td>
          </tr>
          <tr>
            <td valign="top">/sbin/ifconfig<br>
            </td>
            <td valign="top">Inserts network information<br>
            </td>
          </tr>
          <tr>
            <td valign="top">ls -l<br>
            </td>
            <td valign="top">Inserts a directory listing <br>
            </td>
          </tr>
          <tr>
            <td valign="top">galeon --help<br>
            </td>
            <td valign="top">Inserts Galeon's usage information<br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
      </td>
    </tr>
    <tr>
      <td valign="top">
      <pre><b>:w</b></pre>
      </td>
      <td valign="top">Saves the current file<br>
      </td>
    </tr>
    <tr>
      <td valign="top">
      <pre><b>:w filename</b></pre>
      </td>
      <td valign="top">Saves the current file as filename. WARNING!!! The
buffer you are editing is the old filename, not the new one. To edit the
new filename, perform the <tt>:e!</tt> command immediately after <tt>:w filename</tt>.<br>
      </td>
    </tr>
    <tr>
      <td valign="top">
      <pre><b>:4,8w filename</b></pre>
      </td>
      <td valign="top">Saves lines 4 through 8 of the current file to filename.<br>
      </td>
    </tr>
    <tr>
      <td valign="top">
      <pre><b>:4,8w&gt;&gt;filename</b></pre>
      </td>
      <td valign="top">Appends lines 4 through 8 to filename.<br>
      </td>
    </tr><tr>
      <td valign="top"><b><tt>:normal ddp</tt></b><br>
      </td>
      <td valign="top">Example to the left switches the current line with the one below it. <tt>:normal</tt> runs a command mode Vim command from the EX prompt. This is not in VI, but it is in Vim and possibly other implementations.<br>
      </td>
    </tr>

  </tbody>
</table>




<h3>Functions</h3>

In Vim, and probably some other VI implementations, your scripts can have
functions. This provides power to accomplish almost any task, including turning
VI into a different product (like an outliner). In Vim scripts, functions look something
like this:<br>
<br>

<table cellpadding="2" cellspacing="2" border="1" bgcolor="#ccffff">

  <tbody>
    <tr>
      <td valign="top">
      <pre>function MakeChars(count,char)<br>	let i = 0<br>	let chars=""<br>	while i &lt; a:count<br>		let chars = chars . a:char<br>		let i = i + 1<br>	endwhile<br>	return chars<br>endfunction<br></pre>
      </td>
    </tr>
  </tbody>
</table>

<br>
In the preceding, you see functions are delineated by their declaration, and by the word <tt>endfunction</tt>. Arguments are defined in the declaration, and the return statement is what you'd expect. Assignment is via the <tt>let</tt> statement, and you have loops and branching.<br>
<br>
One thing not obvious is functions must not be defined multiple times, so
function definitions and declarations must be surrounded by code to prevent
multiple definition. It looks something like this:<br>
<br>
<table cellpadding="2" cellspacing="2" border="1" bgcolor="#ccffff">
  <tbody>
    <tr>
      <td valign="top">
      <pre>if !exists("loaded_vimoutliner_functions")<br>  let loaded_vimoutliner_functions=1<br><br>  function MakeSpaces(count)<br>      let spaces = MakeChars(a:count," ")<br>      return spaces<br>  endfunction<br><br>  function MakeDashes(count)<br>      let dashes = MakeChars(a:count,"-")<br>      return dashes<br>  endfunction<br><br>endif<br></pre>
      </td>
    </tr>
  </tbody>
</table>
<br>
For more about functions, use the <tt>:h functions</tt> command to see info about built in functions, and the <tt>:h func</tt> command to see function definition syntax.<br>



<h1><a name="_Programmers_Helpers"></a>Programmers Helpers</h1>

<h5>By Steve Litt</h5>

Like most other editors, VI has features to help editing source code. This
article lists the ones common to most VI implementations. The <a href="http://www.troubleshooters.com/lpm/200212/200212.htm#_Vim">Vim</a> article later in this magazine discusses some Vim extensions making source code editing even easier.<br>

<br>

These programmers helpers are common to most VI implementations<br>

<ul>

  <li>Autoindent<br>
  </li>
  <li>Bracket matching</li>
  <li>Tags<br>
  </li>
</ul>

<h2>Autoindent</h2>

You turn on autoindent with the <tt>:set ai</tt> command. You turn it off with the <tt>:set noai</tt>
command. With autoindent on, every time you press Enter in insert mode, the
cursor comes to rest below the beginning of the last line, making programming
indentation much easier. <br>

<br>

Various VI implementations have other indentation settings designed to "help"
the programmer, and in my opinion most of them are best turned off. There
are settings which convert spaces to equivalent tabs and tabs to equivalent
spaces, which to me is incredibly confusing. Whether you indent using tabs
or spaces, you want it consistent. I therefore suggest the following:<br>

<pre>:set ai <br>:set noexpandtab <br>:set nosmarttab <br>:set softtabstop=0 <br>:set nosmartindent <br>:set nocindent</pre>

The preceding uses autoindent, but none of the other "helpful" options that
can end up giving your lines arbitrary combinations of tabs and spaces. Also,
it tells VI not to impose its own indentation rules, but rather to follow
your rules and assist you by assuming a new line starts at the same position
as the one above it.<br>

<br>

When using autoindent you'll find some indenting commands handy:<br>

<table cellpadding="2" cellspacing="2" border="1">

  <tbody>
    <tr>
      <td valign="top" bgcolor="#cccccc">COMMAND<br>
      </td>
      <td valign="top" bgcolor="#cccccc">EFFECT<br>
      </td>
    </tr>
    <tr>
      <td valign="top">
      <pre><b>&gt;&gt;</b></pre>
      </td>
      <td valign="top">Indent in command mode<br>
      </td>
    </tr>
    <tr>
      <td valign="top">
      <pre><b>&lt;&lt;</b></pre>
      </td>
      <td valign="top">Exdent in command mode<br>
      </td>
    </tr>
    <tr>
      <td valign="top">
      <pre><b>Tab</b></pre>
      </td>
      <td valign="top">Indent in insert mode (when at start of line)<br>
      </td>
    </tr>
    <tr>
      <td valign="top">
      <pre><b>Ctrl+T</b></pre>
      </td>
      <td valign="top">Indent in insert mode (from any point on the line)<br>
      </td>
    </tr>
    <tr>
      <td valign="top">
      <pre><b>Ctrl+D</b></pre>
      </td>
      <td valign="top">Extent in insert mode (from any point on the line)<br>
      </td>
    </tr>
  </tbody>
</table>

<h2>
  </h2>

<h2>Bracket Matching</h2>

In an ideal world we'd all indent and document so well that matching beginning
and ending brackets, braces and parens would be intuitively obvious to the
most casual observer. In that ideal world, all maintenance programmers would
retain the obvious matching, and even during development indentation would
be perfect and brackets, braces and parens would never accidentally be omitted.<br>

<br>

For those of us not living in the ideal world, there's bracket matching.
In command mode, simply place the cursor on a square bracket, curly brace
or paren, and press the percent key (<tt>%</tt>). The cursor will jump to
the complementary square bracket, curly brace or paren. This is a 5 second
test to see whether your source code is doing what you really think it is.<br>

<br>

This is a great debugging technique to find the missing or extra brace that
throws off everything else. Better yet, it's a quality control test. If,
upon finishing a subroutine, you bracket match the beginning brace with the
ending brace, you will have removed a large percentage of problems before
testing your code.<br>

<br>

Some VI implementations, such as Vim, have syntax highlighting, which makes
a blown brace instantly visible. But bracket matching is the conclusive test.<br>

<h2>
  </h2>

<h2>Tags</h2>

"Now what were the arguments to that function again?" Sound familiar? Like
most modern professional grade editors, VI has a facility such that when
you encounter a subroutine usage, you can jump to other places where it's
used, as well as where it's declared and where it's defined. This is done
by tagging.<br>

<br>

Here's the simplest way to implement tagging on a project. Find a directory
with a programming project. C is ideal, C++ will probably work, as will Perl
and some other languages. From within that directory, run the following command:<br>

<pre>ctags *</pre>

That will create a new file called <tt>tags</tt>. If you were to look at
the new file you'd notice it's a list of many of your project's variables,
functions and classes, along with the files containing their definitions
and some other information. Once that file is created, go into one of your
source files (not a header file), find a function call, put the cursor over
the function name, and press the Ctrl+] key. You'll be brought to the definition
of the function. Press the Ctrl+T key and you'll be returned to where you
came from. This works for function names, global variables, class names,
and even <tt>#ifdef</tt> constants.<br>

<br>

The preceding discussion is the simplest possible use of tagging. For real
life projects I recommend you review information on the <tt>ctags</tt> program, keeping in mind there are other programs that construct tag files. Pick the best program and options for your needs.<br>



<h5>
Steve Litt is the author of the <a href="http://www.troubleshooters.com/utp/tcourses.htm">Universal
Troubleshooting Process courseware</a>.&nbsp;&nbsp; Steve can be reached
at
<a href="http://www.troubleshooters.com/email_steve_litt.htm">Steve Litt's email address</a>.</h5>



<h2>Learning Vim</h2>

need to find out what directory contains your help text. Perform the <tt>:h</tt> command to bring up <tt>help.txt</tt>,
and press the Ctrl+G key combination to see what directory it's in. Then,
at the bash prompt, go to that directory, and run a grep command. For instance,
if you want help on "matching", try this:<br>
<pre>grep -i -C5 match * | less</pre>

Then you can search the retrieved information to discover which help file
would help you, and within Vim access that help file with the <tt>:h filename</tt> command, where <tt>filename</tt> is the name of the help file.<br>




<h1>
<a name="_VimOutliner"></a>VimOutliner</h1>


<table cellpadding="5" cellspacing="0" border="1" align="center">

  <tbody>
    <tr>
      <td valign="top">
      <pre><b>Grocery Store<br>	Cereal<br>		Trail mix<br>		Sugary cereal<br>	Meat<br>		4 lbs ground beef<br>		1 chicken<br>	Household<br>		Toilet paper<br>		Laundry detergent<br>Vegetable Stand<br>	Bananas<br>	Green peppers<br>Pharmacy<br>	Prescription<br>	Video tapes</b><br></pre>
      </td>
    </tr>
  </tbody>
</table>
<br>
The classic use of outlines is the structuring of a book or other large document.
My outline for "Samba Unleashed" was over 2800 lines. Anyone writing a
nonfiction book will most likely fail to finish if they don't start with
an outline, and even if they finish, the book will be full of chapter interdependencies,
forward references and redundancy -- in other words, it will be terrible.<br>
<br>
Who needs outlining? Anyone who is too busy to waste time correcting mistakes.
Outlines are a planning tool that help you do the job right the first time.<br>
<br>
25 years ago, creating an outline was a&nbsp; cumbersome job in and of itself,
requiring constant writing, erasing, and rewriting on paper. Rearranging
your outline back required either filling your outline with long, looping
arrows, or more likely, a complete rewrite.<br>
<br>
Then outliner processors were invented. An outline processor is a software
program enabling the user to quickly construct outlines, and better yet,
to correct and rearrange the outline. Keeping in mind that lines of an outline
are called "headlines", outline processors typically have the following capabilities:<br>
<br>
<table cellpadding="2" cellspacing="2" border="1" width="100%">
  <tbody>
    <tr>
      <td valign="top" bgcolor="#cccccc"><b>Capability<br>
      </b></td>
      <td valign="top" bgcolor="#cccccc"><b>Meaning<br>
      </b></td>
      <td valign="top" bgcolor="#cccccc"><b>VimOutliner Implementation<br>
      </b></td>
    </tr>
    <tr>
      <td valign="top">Insertion<br>
      </td>
      <td valign="top">Add a headline.<br>
      </td>
      <td valign="top">Vim Insertion commands<br>
      </td>
    </tr>
    <tr>
      <td valign="top">Deletion<br>
      </td>
      <td valign="top">Delete a headline, possibly including all the headlines subservient to the headline.<br>
      </td>
      <td valign="top">Vim line deletion commands<br>
      </td>
    </tr>
    <tr>
      <td valign="top">Demotion<br>
      </td>
      <td valign="top">Make a headline subservient to the one above it<br>
      </td>
      <td valign="top">Tab key, VI <tt>&gt;&gt;</tt> command, or Ctrl+T within insert mode<br>
      </td>
    </tr>
    <tr>
      <td valign="top">Promotion<br>
      </td>
      <td valign="top">Make a headline equal or superior to the one above it <br>
      </td>
      <td valign="top">VI deletions on beginning tabs, <tt>&lt;&lt;</tt> command, or Ctrl+D within insert mode<br>
      </td>
    </tr>
    <tr>
      <td valign="top">Rearrangement<br>
      </td>
      <td valign="top">Move a headline or an entire tree to a different location in the outline<br>
      </td>
      <td valign="top">VI
delete followed immediately by a VI paste in the new location. Soon will
also be implemented with "move up one place" and "move down one place" keystrokes<br>
      </td>
    </tr>
    <tr>
      <td valign="top">Copying<br>
      </td>
      <td valign="top">Copy a headline or tree to another location in the outline<br>
      </td>
      <td valign="top">VI yank  followed immediately by a VI paste in the new location</td>
    </tr>
    <tr>
      <td valign="top">Collapse<br>
      </td>
      <td valign="top">Make every headline in the tree below the headline
of interest invisible. This is good for getting the "big picture". When the
entire headline is collapsed to a certain level, this also facilitates quick
location of the tree of interest<br>
      </td>
      <td valign="top">Vim
folding, together with specialized Vim functions to facilitate visually pleasing
collapsing. Collapsing on a single tree or whole outline basis facilitated
by Vim folding commands.<br>
      </td>
    </tr>
    <tr>
      <td valign="top">Expand<br>
      </td>
      <td valign="top">The opposite of collapsing, expanding makes collapsed
headlines visible again. Expanding can be all the way down the tree, or only
to a certain level, such that below that level the headlines are still collapsed.<br>
      </td>
      <td valign="top">Vim folding, together with specialized Vim functions
to facilitate visually pleasing collapsing. Expanding on a single tree or
whole outline basis facilitated by Vim folding commands.</td>
    </tr>
    <tr>
      <td valign="top">Spawning<br>
      </td>
      <td valign="top">Running a program or command directly from a specially
configured headline. Typical use is to bring up an html file in a browser
or an OpenOffice document in OpenOffice. Having this capability enables you
to have a true single-tree knowledge base.<br>
      </td>
      <td valign="top">Not yet in VimOutliner (as of 0.2.0), but the team has successfully prototyped it and expect it to be in the next version.<br>
      </td>
    </tr>
<tr>
      <td valign="top">Body text<br>
      </td>
      <td valign="top">A lowest level entity that word wraps. Having this enables a substantial part of a document's writing process to occur within the outline.<br>
      </td>
      <td valign="top">Not yet in VimOutliner (as of 0.2.0), but the team has successfully prototyped it and expect it to be in the next version.
      </td>
    </tr>
    <tr>
      <td valign="top">Headline numbering<br>
      </td>
      <td valign="top">Numbering of the outline's headlines, typically III, C, 3, c, etc.<br>
      </td>
      <td valign="top">Not implemented in VimOutliner. However, scripts exist to export VimOutliner outlines into a numbered outline.<br>
      </td>
    </tr>
    <tr>
      <td valign="top">Interoutline linking</td>
      <td valign="top">Links between outlines similar to links on web pages. Interoutline links
are used to create "superhierarchies" where a master outline links to suboutlines,
themselves linked to sub-suboutlines, and so on. Conceptually this enables
you to place all your knowledge in a single hierarchy for quick and easy
recording and retrieval.<br>
      </td>
      <td valign="top">Vim tags and the <tt>ctags</tt> program<br>
      </td>
    </tr>
    <tr>
      <td valign="top">Headline appearance by level<br>
      </td>
      <td valign="top">Outlines are much easier to read if headlines at different
levels have different appearances. The distinct appearance is typically the
result of a different font or a different color.<br>
      </td>
      <td valign="top">Vim syntax facilities to color leveled colors. Scripts
could be written to export an outline to html, with various fonts, for printing.<br>
      </td>
    </tr>
    <tr>
      <td valign="top">Hoisting and dehoisting<br>
      </td>
      <td valign="top">The ability to temporarily treat a subtree as a main
outline, with the subheadlines at the top level. This facilitates greater
focus on a small area of interest.<br>
      </td>
      <td valign="top">Not yet implemented in VimOutliner, but it's being discussed.<br>
      </td>
    </tr>
    <tr>
      <td valign="top">Groupware<br>
      </td>
      <td valign="top">The
ability for many people to simultaneously work on the outline, thus "brainstorming"
together. Few if any outline processors feature groupware.<br>
      </td>
      <td valign="top">Not yet implemented in VimOutliner, but it's being discussed.
      </td>
    </tr>
    <tr>
      <td valign="top">Diagramming<br>
      </td>
      <td valign="top">The ability to turn an outline into a diagram.<br>
      </td>
      <td valign="top">Not specifically implemented, but doable with perl scripts.<br>
      </td>
    </tr>
    <tr>
      <td valign="top">Cloning<br>
      </td>
      <td valign="top">The
ability to have one headline be a reference to another, such that when one
changes the other changes identically. This feature is useful in rapid-fire
associative thinking, and in computer program design.<br>
      </td>
      <td valign="top">Not yet implemented in VimOutliner.
      </td>
    </tr>
    <tr>
      <td valign="top">Fast retrieval<br>
      </td>
      <td valign="top">The ability to retrieve anything in the outline quickly with a minimum of keystrokes.<br>
      </td>
      <td valign="top">Implemented with VI's search command. Further quick lookup features might later be added.<br>
      </td>
    </tr>
  </tbody>
</table>
<h2>Obtaining VimOutliner</h2>
VimOutliner is free software that can be downloaded from http://www.troubleshooters.com/vimoutliner/.
The current version is 0.2.0, and is downloaded as a 25K (that's Kilobyte)
file. Simply extract the tarball in the directory above where you want its
executables to reside, and the tarball will create an <tt>otlbin</tt> directory under it. Within the <tt>otlbin</tt> directory, while logged in as the user who will be using VimOutliner, run the <tt>./install.pl</tt> script. The script asks 3 questions, and if you answer "yes" to all 3, VimOutliner is automatically installed for that user.<br>
<br>
The current VimOutliner is known to work on Linux. We have every reason to
believe it will work on any UNIX clone or workalike, including BSD and OS/X.
We suspect it can be adapted to Windows usage, but have not yet made the
port.<br>
<h2>Summary</h2>

Because so much of the world around us, and so much of human thinking, is
hierarchical in nature, the outline has always been the design tool of choice
for writers, and the planning tool of people too busy to work by trial and
error. Outlining is so powerful that even before computers, when outlining
was a painful pencil and paper process involving writing, marking up, and
rewriting, outlines were used extensively.<br>
<br>
With the advent of computerized outline processors, the cost of outlining
has plunged. In the pencil and paper days creating a finished 200 headline
outline could have taken several days. Today, assuming most of the the research
and though have been completed, a 200 headline outline would take between
2 and 6 hours.<br>
<br>
With different features and keystroke interfaces, computerized outline processors
vary widely in their productivity. Due to the incredibly efficient VI keyset,
VimOutliner is probably the most productive outline creation tools. The current
version (0.2.0, released 12/3/2002) has the following fully developed features:<br>
<ul>
  <li>Insertion/Deletion</li>
  <li>Demotion/Promotion</li>
  <li>Rearrangement</li>
  <li>Copying</li>
  <li>Collapse/Expand</li>
  <li>Interoutline linking</li>
  <li>Level based coloration</li>
  <li>Fast retrieval</li>
</ul>
Two additional important features, <i>spawning</i> and <i>body text</i>,
have already been prototyped by the VimOutliner team, and almost certainly
be added to the next version (after 0.2.0). Other features such as <i>hoisting/dehoisting</i>, <i>spellcheck</i>, <i>user friendly menu interface</i>, <i>level aware sorting</i>, and <i>single step rearrangement</i>
are being actively developed, and some of these features are likely to make
the next version. It's very likely that the next VimOutliner version will
be more featureful than commercial outliners.<br>
<br>
Perhaps most intriguing is the fact that the VimOutliner team has discussed
techniques to add groupware capability to VimOutliner. When that feature
is in place, VimOutliner can be expected to be the best of breed outline
processor, for any price, on any kind of computer.<br>
<br>

</body><style type="text/css">embed[type*="application/x-shockwave-flash"],embed[src*=".swf"],object[type*="application/x-shockwave-flash"],object[codetype*="application/x-shockwave-flash"],object[src*=".swf"],object[codebase*="swflash.cab"],object[classid*="D27CDB6E-AE6D-11cf-96B8-444553540000"],object[classid*="d27cdb6e-ae6d-11cf-96b8-444553540000"],object[classid*="D27CDB6E-AE6D-11cf-96B8-444553540000"]{	display: none !important;}</style></html>
