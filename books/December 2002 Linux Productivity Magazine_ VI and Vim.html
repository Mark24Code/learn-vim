<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<!-- saved from url=(0071)http://www.troubleshooters.com/lpm/200212/200212.htm#_VI_Life_Preserver -->
<html class="gr__troubleshooters_com"><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
  <meta name="Author" content="Steve Litt">
  <meta name="GENERATOR" content="Mozilla/4.78 [en] (X11; U; Linux 2.4.18-6mdksmp i686) [Netscape]">
  <meta name="Description" content="Using the Zope Portal Building Software">
  <meta name="Keywords" content="Zope,website,websites,portal,portals,web portal,web authoring,web authoring tool,web authoring tools,web app,web application,web applications,Python,Zope Corporation,Digital Creations"><title>December 2002 Linux Productivity Magazine: VI and Vim</title><style id="style-1-cropbar-clipper">/* Copyright 2014 Evernote Corporation. All rights reserved. */
.en-markup-crop-options {
    top: 18px !important;
    left: 50% !important;
    margin-left: -100px !important;
    width: 200px !important;
    border: 2px rgba(255,255,255,.38) solid !important;
    border-radius: 4px !important;
}

.en-markup-crop-options div div:first-of-type {
    margin-left: 0px !important;
}
</style></head>
<body text="#000000" bgcolor="#ffffff" link="#0000ee" vlink="#551a8b" alink="#ff0000" data-gr-c-s-loaded="true" data-pinterest-extension-installed="cr2.0.5">

<h1>
<a name="_Elementary_Search_and_Replace_and_Global_Commands"></a>Search and Replace: Substitute and Global Commands</h1>


<h2><a name="Ranges"></a>Ranges</h2>


<table cellpadding="2" cellspacing="2" border="1">


  <tbody>
    <tr>
      <td valign="top" bgcolor="#cccccc">Range<br>
      </td>
      <td valign="top" bgcolor="#cccccc">Example<br>
      </td>
      <td valign="top" bgcolor="#cccccc">Explanation<br>
      </td>
    </tr>
    <tr>
      <td valign="top">4,7<br>
      </td>
      <td valign="top">:4,7s/Windows/Linux/<br>
      </td>
      <td valign="top">Runs the substitution command on lines 4 through 7 inclusive.<br>
      </td>
    </tr>
    <tr>
      <td valign="top">4;7<br>
      </td>
      <td valign="top">:4;7s/Windows/Linux/</td>
      <td valign="top">Runs the substitution command on line 4, and the 7
lines following it. Note the distinction between the semicolon version, which
calculates the second value relative to the first.<br>
      </td>
    </tr>
    <tr>
      <td valign="top">4<br>
      </td>
      <td valign="top">:4s/Windows/Linux/</td>
      <td valign="top">Runs the substitution command on line 4 only.<br>
      </td>
    </tr>
    <tr>
      <td valign="top">4,$<br>
      </td>
      <td valign="top">:4,$s/Windows/Linux/</td>
      <td valign="top">Runs the substitution command on lines 4 through the
file's last line, inclusive. In line ranges, the &nbsp;$ character represents
the last line in the file.</td>
    </tr>
    <tr>
      <td valign="top">4,.<br>
      </td>
      <td valign="top">:4,.s/Windows/Linux/</td>
      <td valign="top">Runs the substitution command on lines 4 through the line the cursor is on, inclusive.
In line ranges, the . character represents the current line.</td>
    </tr>
    <tr>
      <td valign="top">.,2000<br>
      </td>
      <td valign="top">:.,2000s/Windows/Linux/</td>
      <td valign="top">Runs the substitution command on the current line
through line 2000 inclusive. This shows that the dot can be used as the beginning,
or as the end of a range.</td>
    </tr>
    <tr>
      <td valign="top">.,.+3<br>
      </td>
      <td valign="top">:.,.+3s/Windows/Linux/</td>
      <td valign="top">Runs the substitution command on the current line
through the line three below the current line inclusive. In other words,
this line plus the next three. In general, you add and subtract from a range
value by appending a plus and number, or a minus and number. Be careful not
to go too far or too short by one -- it's easy to do.</td>
    </tr>
    <tr>
      <td valign="top">.,+3</td>
      <td valign="top">:.,+3s/Windows/Linux/</td>
      <td valign="top">CAREFUL!!! This produces the identical result to the
preceding example, even though we removed the dot in the range end expression.
In a + or - expression, if what it's relative is not explicitly declared,
it defaults to "current line". This can lead to confusion. Use the version
with the dot.<br>
      </td>
    </tr>
    
    <tr>
      <td valign="top"><small><small>/My_Opinion/,$</small></small><br>
      </td>
      <td valign="top"><small><small>:/My_Opinion/,$s/Windows/Linux/</small></small></td>
      <td valign="top">Search forward for the next occurrence of My_Opinion,
and run the substitution on that line through the end of file, inclusive.
Note that the search will not find matches on the current line.</td>
    </tr>
  </tbody>
</table>


<h3>Searches in Ranges</h3>


The final example in the preceding table shows a search in a range. This
makes VI incredibly powerful, and if done casually incredibly dangerous.
But here let's discuss the power. A search can appear in either the range
start expression, the range end expression, or both. The search can be forward
or backward. The line found by the search can be added to or subtracted from.<br>


<br>


<table cellpadding="2" cellspacing="2" border="1" width="50%" align="center">


  <tbody>
    <tr>
      <td valign="top">
      <div align="center"><font size="+1" color="#cc0000"><b>WARNING</b></font><br>
      </div>
If you have wrapscan set, searches in ranges can do some strange things.
A forward search can fail to find the string by end of file, wrap back up,
and find one above where you are. Likewise, a backward search can wrap around
the top and find a match below you. These typically are not what you want.<br>
      <br>
To make your results more predictable, before running commands with searches
in ranges, turn off wrapscan with the following command:<br>
      <pre>:set nowrapscan</pre>
Later, if you want to restore wrapscan so you can find a pattern anywhere in the file, restore it with this command:<br>
      <pre>:set wrapscan</pre>
      </td>
    </tr>
  </tbody>
</table>


<br>


Remembering to set nowrapscan, see the following examples:<br>


<br>


<table cellpadding="2" cellspacing="2" border="1">


  <tbody>
    <tr>
      <td valign="top" bgcolor="#cccccc">Range<br>
      </td>
      <td valign="top" bgcolor="#cccccc">Function<br>
      </td>
      <td valign="top" bgcolor="#cccccc">Explanation<br>
      </td>
    </tr>
    <tr>
      <td valign="top">:/My_Opinion/,$s/Windows/Linux/</td>
      <td valign="top">Search forward<br>
      </td>
      <td valign="top">Search forward from the current line to the next line
containing "My_Opinion", and from that line to the end of file substitute
"Linux" for "Windows". The search WILL NOT match any "My_Opinion" on the
current line, and instead will match the next downward occurrence of "My_Opinion".</td>
    </tr>
    <tr>
      <td valign="top">:?My_Opinion?,$s/Windows/Linux/</td>
      <td valign="top">Search backward<br>
      </td>
      <td valign="top">Search backward from the current line to the next line up containing "My_Opinion",
and from that line to the end of file substitute "Linux" for "Windows". The
search WILL NOT match any "My_Opinion" on the current line.
The search WILL NOT match any "My_Opinion" on the current line, and instead
will match the next upward occurrence of "My_Opinion".</td>
    </tr>
    <tr>
      <td valign="top">:1+/My_Opinion/,$s/Windows/Linux/</td>
      <td valign="top">Search forward from line 1<br>
      </td>
      <td valign="top">The previous searches started from the current line,
which may or may not be what you want. If starting the command with a known
state is important to you, use this command form to start from line 1. Note
that this will not find a match on line 1, so if that's an issue you'll need
to run an additional command to get the lines you missed.<br>
      </td>
    </tr>
    <tr>
      <td valign="top">:2+?My_Opinion?;/My_Opinion/-1s/Windows/Linux/<br>
      </td>
      <td valign="top">See comment<br>
      </td>
      <td valign="top">If the first line contains "My_Opinion", the preceding
command did not substitute on that line or any lines until the next occurrence
of "My_Opinion". You probably want those lines substituted. This command
does that. Starting at line 2, it goes backward (you did set nowrapscan to
prevent search wrapping, didn't you?), and if it finds "My_Opinion" on line
1, it alters line 1 and every line until, and including, the line before
the next "My_Opinion", which presumably was fixed by the preceding command.<br>
      </td>
    </tr>
  </tbody>
</table>


<h1>
<a name="_Regular_Expressions"></a>Regular Expressions</h1>

<h2>Character Sets</h2>




<br>


<table cellpadding="2" cellspacing="2" border="1" width="50%" align="center">


  <tbody>
    <tr>
      <td valign="top">
      <div align="center"><b><font size="+1">IMPORTANT</font></b><br>
      </div>
      <br>
A character set matches only a single character. It cannot match a phrase.
It is only when character sets are grouped with other character sets, other
characters, and iterators, that they can match phrases.<br>
      </td>
    </tr>
  </tbody>
</table>


<br>


<br>


Many character sets are so common that VI shortcuts are provided for them. Here are some character set shortcuts:<br>


<br>


<table border="1" cellpadding="3" nosave="">



<tbody><tr nosave="">
<td nosave="" bgcolor="#cccccc"><b><tt>Shortcut</tt></b></td>

<td bgcolor="#cccccc"><b><tt>Equivalent
      <br>
Character
      <br>
Set</tt></b></td>

<td bgcolor="#cccccc">What it matches</td>
</tr>

<tr>
<td><b><tt>\d</tt></b></td>

<td><b><tt>[0-9]</tt></b></td>

<td>digit</td>
</tr>

<tr>
<td><b><tt>\D</tt></b></td>

<td><b><tt>[^0-9]</tt></b></td>

<td>Any character except a digit</td>
</tr>

<tr>
<td><b><tt>\s</tt></b></td>

<td><b><tt>[ \t\n\r]</tt></b></td>

<td>whitespace</td>
</tr>

<tr>
<td><b><tt>\S</tt></b></td>

<td><b><tt>[^ \t\n\r]</tt></b></td>

<td>Any character that is not whitespace</td>
</tr>

<tr>
<td><b><tt>\w</tt></b></td>

<td><b><tt>[a-zA-Z0-9]</tt></b></td>

<td>"word char" : i.e. alphanumeric, not space or punctuation</td>
</tr>

<tr>
<td><b><tt>\W</tt></b></td>

<td><b><tt>[^a-zA-Z0-9]</tt></b></td>

<td>"word separator" : i.e. space or punctuation, also
not EOL or BOL</td>
</tr><tr>
      <td valign="top">\l<br>
      </td>
      <td valign="top">[a-z]<br>
      </td>
      <td valign="top">Lowercase
letter. In the search expression it matches any lower case letter. In the
replace expression it lowercases the character or character representer following
it.<br>
      </td>
    </tr>
    <tr>
      <td valign="top">\L<br>
      </td>
      <td valign="top">[^a-z]<br>
      </td>
      <td valign="top">In the search expression \L matches any character except except a lowercase letter.
In the replace expression it makes everything that follows it, to the end
of the replace expression, lower case. However, a later \U in the replace
expression ends its effect.<br>
      </td>
    </tr>
    <tr>
      <td valign="top">\u<br>
      </td>
      <td valign="top">[A-Z]<br>
      </td>
      <td valign="top">Uppercase
letter.  In the search expression it matches any lower case letter. In the
replace expression it capitalizes the character following it.       </td>
    </tr>
    <tr>
      <td valign="top">\U<br>
      </td>
      <td valign="top">[^A-Z]<br>
      </td>
      <td valign="top">In the search expression \U matches any character except except an uppercase letter.
In the replace expression it makes everything that follows it, to the end
of the replace expression, upper case. However, a later \L in the replace
expression ends its effect.
      </td>
    </tr>

</tbody>
</table>


<br>

There are also special strings that represent positions in a line instead of characters:<br>


<br>


<table cellpadding="2" cellspacing="2" border="1">


  <tbody>
    <tr>
      <td valign="top" bgcolor="#cccccc">Positional<br>
Representer<br>
      </td>
      <td valign="top" bgcolor="#cccccc">Example<br>
      </td>
      <td valign="top" bgcolor="#cccccc">Meaning<br>
      </td>
    </tr>
    <tr>
      <td valign="top"><tt><b>^<br>
      </b></tt></td>
      <td valign="top"><tt><b>:s/^/cp /</b></tt></td>
      <td valign="top"><tt>^</tt> Means beginning of line. This example "replaces"
the beginning of line with cp followed by a space, creating a copy command
from a directory listing. Note that when you "replace" a positional representer,
there's nothing to replace, so you simply put the replaced text in the position
represented by the positional representer.<br>
      </td>
    </tr>
    <tr>
      <td valign="top"><tt><b>$<br>
      </b></tt></td>
      <td valign="top"><tt><b>:s/$/ backupdir/</b></tt></td>
      <td valign="top"><tt>$</tt> means end of line. This example puts a space followed by <tt>backupdir</tt> at the end of the line, finishing the copy command you started with the carat example.<br>
      </td>
    </tr>
    <tr>
      <td valign="top"><tt><b>\&lt;<br>
      </b></tt></td>
      <td valign="top"><tt><b>:s/\&lt;sed/awk/g</b></tt></td>
      <td valign="top"><tt>\&lt;</tt> means a the word's beginning boundary.
It is neither the first character of the word, nor the whitespace or punctuation
before it, but instead an imaginary position between the two, or in the case
where the word is at the start of the line, it exactly overlays <tt>^</tt>. This example finds every word starting with the string <tt>sed</tt> and replaces that string with <tt>awk</tt>. But, for instance, it would leave the word "ba<i>sed</i>" unharmed, because the string <tt>sed</tt> is not at the beginning of the word.<br>
      </td>
    </tr>
    <tr>
      <td valign="top"><tt><b>\&gt;<br>
      </b></tt></td>
      <td valign="top"><tt><b>:s/\&lt;sed\&gt;/awk/g</b></tt></td>
      <td valign="top"><tt>\&gt;</tt> means a the word's ending boundary. It is neither the last
character of the word, nor the whitespace or punctuation after it, but instead
an imaginary position between the two, or in the case where the word is at
the end of the line, it exactly overlays <tt>$</tt>. This example finds every word <tt>sed</tt> and replaces that word with <tt>awk</tt>. But, for instance, it would leave the word "ba<i>sed</i>" unharmed, and also the word "<i>sed</i>iment", because the string <tt>sed</tt> is not at both the beginning and end of the search pattern.</td>
    </tr>
  </tbody>
</table>



<h2>Enumerators</h2>

A\{2, 4}</tt> matches AA, AAA, or even AAAAAAAAA, but it does not match a single A not followed or preceded by an additional A.<br>

So you might wonder what the second number is. The second number is how far
you skip before trying to find another match. For instance, take a string
with 13 A characters in a row, preceded and followed by a space.<br>


<pre>/A\{2,4} the first time<br>AAAAAAAAAAAAA<br>^<br><br><br>/A\{2,4} the second time<br>AAAAAAAAAAAAA<br>    ^<br><br><br>/A\{2,4} the third time<br>AAAAAAAAAAAAA<br>        ^<br><br><br>/A\{2,4} the fourth time (no match, because only 1 A remains)<br>AAAAAAAAAAAAA<br>            <br></pre>


The first time it matches the first 4 letters. The second time it matches
the second four. The third time it matches the third four. Now it gets interesting.
It doesn't match the last A because there's only one left. If there had been
14 A's instead of 13, it would have matched the last 2. So the last number
is the maximum match, and the number it skips ahead to begin trying for the
next match.<br>


<br>


Remember also that the character being enumerated can be a character set.
For instance, the following finds strings of 2 to 100 instances of whitespace
(presumably to convert them to nothing, thereby squeezing out repeated spaces)<br>


<pre>\s\{2,100}<br></pre>


That brings up a good point. You really wanted 2 to infinity, not 2 to 100.
Another way of saying 2 to infinity is 2 or more, and the enumerator for
that is <tt>\{2,}</tt>. That matches 2 or more consecutive A characters,
and matches all of them, so that subsequent matches won't match any more
of that consecutive run.<br>


<br>


Perhaps you want to match exactly two of a character. The enumerator for that is <tt>\{2}</tt>. <br>


<br>


There are shortcuts for the most common enumerators, namely, 0 or more, 1 or more, and 0 or 1:<br>


<br>


<table cellpadding="2" cellspacing="2" border="1">


  <tbody>
    <tr>
      <td valign="top" bgcolor="#cccccc">Shortcut<br>
      </td>
      <td valign="top" bgcolor="#cccccc">Equivalent enumerator<br>
      </td>
      <td valign="top" bgcolor="#cccccc">Meaning<br>
      </td>
    </tr>
    <tr>
      <td valign="top">*<br>
      </td>
      <td valign="top">\{0,}<br>
      </td>
      <td valign="top">0 or more<br>
      </td>
    </tr>
    <tr>
      <td valign="top">\+<br>
      </td>
      <td valign="top">\{1,}<br>
      </td>
      <td valign="top">1 or more<br>
      </td>
    </tr>
    <tr>
      <td valign="top">\?<br>
      </td>
      <td valign="top">\{0,1}<br>
      </td>
      <td valign="top">0 or 1<br>
      </td>
    </tr>
  </tbody>
</table>


<br>


The following matches a traditional 10 digit phone number:<br>


<pre>/(\d\{3})[-[:space:]]\?\d\{3}-\d\{4}<br></pre>


The preceding is read as follows:<br>


<br>


An opening paren, followed by exactly three digits, followed by a closing paren, followed by zero or one
instance of either a whitespace character or a dash, followed by exactly
three digits, followed by a dash, followed by exactly four digits.<br>

<h2><a name="Using_Matched_Text_as_Replacement_Text"></a>Using Matched Text as Replacement Text</h2>


Something that comes up with surprising regularity is the need to switch
2 parts of every line. For instance, consider a comma delimited data file.
What if you need to switch the first and second fields? Here's how you do
it:<br>


<pre>:%s/\([^,]*\),\([^,]*\),\(.*\)/\2,\1,\3/<br></pre>


Your first reaction might be that the preceding is ugly. That's true, but
compare it to writing a program or creating a macro like you need to do in
so many other editors.<br>


<br>


Here's a character by character explanation of the preceding command:<br>


<table cellpadding="3">


  <tbody>
    <tr>
      <td valign="top" align="right">
      <pre><b>:%s</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Substitute&nbsp;on every line<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right"><b>/<br>
      </b></td>
      <td valign="top"><br>
      </td>
      <td valign="top">Begin search expression<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\(</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Begin a group. The group is ended by \). Everything
inside a search expression group is remembered such that it can be used within
the replace text.<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>[^,]</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">A character set that matches everything EXCEPT a comma.
In a comma delimited file, this is how you implement short matching so the
match ends on the first comma.<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right"><b><tt>*</tt><br>
      </b></td>
      <td valign="top"><br>
      </td>
      <td valign="top">An enumerator indicating zero or more of the character
or character set that preceded it. In this case, it means zero or more non-commas.
Those zero or more non-commas correspond to the first field in the line.<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\)</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Ends the first group.<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right"><b><tt>,</tt><br>
      </b></td>
      <td valign="top"><br>
      </td>
      <td valign="top">Matches a comma, which is the field delimiter in a comma delimited file.<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\(</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Begins the second group<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>[^,]*</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Zero or more non-commas corresponding to the second field<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\)</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Ends the second group<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right"><b><tt>,</tt><br>
      </b></td>
      <td valign="top"><br>
      </td>
      <td valign="top">Matches the comma that separates the second field from the third field<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\(</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Begins the third group</td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>.*</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Zero or more characters of any type. This represents
the rest of the line. Because the only fields you're modifying are the first
and second, you can group the third, fourth, ... fields together into one
group -- the third group.<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\)</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Ends the third group<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right"><b>/<br>
      </b></td>
      <td valign="top"><br>
      </td>
      <td valign="top">Ends the search expression and begins the replace expression<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\2</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">The text that was matched by the second group of the
search expression, which, in fact, was the second field, which we are now
putting first<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right"><b><tt>,</tt><br>
      </b></td>
      <td valign="top"><br>
      </td>
      <td valign="top">Literal comma to separate the first and second fields in the replaced text.<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\1</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Text matched by the first group in the search expression, which we are now putting second.<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>,</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Literal comma to separate the new second field from the third<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\3</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Text matched by the third group in the search expression, which in fact represented all fields after the first two<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>/</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Ends the replace expression<br>
      </td>
    </tr>
  </tbody>
</table>


<br>


Study the preceding information. Once you understand the preceding, you understand
most of what it takes to use search information in the replace expression.
Here's another example -- a titlecase converter:<br>


<pre><b>:%s/\&lt;\(.\)\([^[:space:][:punct:]]*\)\&gt;/\u\1\2/g</b><b><tt><br></tt></b></pre>


You might use this in a VI based book outline in order to titlecase all headings
for later use as parts, sections, subsections, etc. Let's quickly analyze:<br>


<table cellpadding="3">


  <tbody>
    <tr>
      <td valign="top" align="right">
      <pre><b>:s</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Substitute on every line<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>/</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Start search expression<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\&lt;</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Matches position at beginning of word (between the
space or punctuation preceding the word and the first alphanumeric of the
word<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\(.\)</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Group containing the first character of the word<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\(</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Begin second group<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>[^[:space:][:punct:]]*</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Series
(zero or more) characters that are neither whitespace nor punctuation. This
makes up the remainder of the word. This is discussed further in the <a href="http://www.troubleshooters.com/lpm/200212/200212.htm#Short_Matching">Short Matching</a> section of this article.<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\)</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">End second group<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\&gt;</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Matches position at end of word (between the last alphanumeric of the word and the punctuation or space following the word)<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>/</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Ends the search expression and begins the replace expression<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\u</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Means the next character or metacharacter will be capitalized<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\1</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">The text that matched the first group of the search
expression. In this case that means the first character of the word, which
due to the \u before it in the replace expression, means it's capitalized.<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\2</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">The text that matched the second group of the search expression. In this case that means the remainder of the word.<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>/</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Ends the replace expression<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>g</b></pre>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top">Means global, meaning that you don't quit on the first
match. This is what enables this title case converter to work on every word
of the line.<br>
      </td>
    </tr>
  </tbody>
</table>


<br>



Once again, review the preceding, especially noting the use of \&lt; and \&gt; to delineate words, the use of <br>


<tt>[^[:space:][:punct:]]*</tt> to represent the remainder of a word, and the use of \u to uppercase the next item in the replace expression.<br>


<br>


The following table lists several pieces of syntax used when you use matched text in the replacement:<br>


<table cellpadding="2" cellspacing="2" border="1">


  <tbody>
    <tr>
      <td valign="top" align="right">
      <pre><b>\(.....\)</b></pre>
      </td>
      <td valign="top">Delineates
a group. Whatever matches the expression inside the \( and \) is remembered
and available in the replace expression. In this example, any series of 5
characters matches the expression inside the \( and \).</td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\1</b></pre>
      </td>
      <td valign="top">Used inside the replace expression, this is replaced by the text matched by the first group in the search expression.<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\2<br></b></pre>
      </td>
      <td valign="top">Used inside the replace expression, this is replaced
by the text matched by the second group in the search expression. Likewise
\3 is replaced by the text matched by the third group, \4 by the text matched
by the 4th group, all the way up to \9.</td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\u</b></pre>
      </td>
      <td valign="top">Used in the search expression, this matches any upper
case letter. Used in the replace expression, this uppercases the next single
item in the replacement expression.<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\l</b></pre>
      </td>
      <td valign="top">Used in the search expression, this matches any lower case letter. Used in
the replace expression, this lowercases the next single item in the replacement
expression.</td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\U</b></pre>
      </td>
      <td valign="top">Used in the search expression, this matches any character that IS NOT an upper case letter. Used in
the replace expression, this uppercases the remainder of the replacement
expression. However, a later \L in the replace expression will "turn off" the \U at the point of appearance of the \L.</td>
    </tr>
    <tr>
      <td valign="top" align="right">
      <pre><b>\L</b></pre>
      </td>
      <td valign="top">Used in the search expression, this matches any character that IS NOT a lower case letter. Used in
the replace expression, this lowercases the remainder of the replacement
expression. However, a later \U in the replace expression will "turn off" the \L at the point of appearance of the \U.</td>
    </tr>
  </tbody>
</table>


<br>


Using matched text is one of VI's most powerful features. Many other word
processors require you to write a macro in order to accomplish similar things.
Of course you could write the same types of macros in VI, but once you get
used to regular expressions it takes only 1/4 to 1/10 the time.<br>


<h2><a name="Short_Matching"></a>Short Matching<br>
</h2>



Consider the following sentence:<br>


<br>


<i>I will roll the wheel from the whalebelly to the well.</i><br>


<br>


Let's say you want to find every string that begins with w and ends with
ll, replacing it with XXX. You want the line changed to the following:<br>


<br>


<i>I XXX roll the wheel from the XXXy to the XXX.</i><br>


<br>


How bout this:<br>


<pre>s/w.*ll/XXX/g<br></pre>


The <tt>g</tt> on the end means global, meaning keep finding and replacing
after finding the first one. Unfortunately, the preceding regex will instead
produce the following:<br>


<br>


<i>I XXX.<br>
</i><br>

What happened? Unless told otherwise, regular expressions match as
much as possible. So it found the first w (the one in will), and the last
ll (the one in well), and replaced them, and everything in between, with
XXX. How would you make the matches as short as possible? &nbsp;Some environments,
such as Perl, have special modifiers enabling enumerators to match as short
as possible. This isn't available in many VI &nbsp;implementations.<br>


<br>


What's needed is a way to limit the scope of the enumerator. Consider the following:<br>


<pre>:s/w[^l]*ll/XXX/g<br></pre>



This is much closer, producing the following:<br>


<br>


<i>I XXX roll the wheel from the whalebelly to the XXX.</i><br>


<br>


It found "will" and "well", but missed "whalebell". What happened is the
first "l" in "whalebelly" reset the search, so that the search went back
to searching for "w", moving all the way to the last word of the line.<br>


<br>


If we can agree that we should match long on a per word basis (in other words,
"wellwall" will be replaced by XXX and not XXXXXX), we can limit by word
boundaries instead of the "l" character:<br>


<pre>:s/w[^[:space:][:punct:]]*ll/XXX/g<br></pre>


The preceding produces the desired:<br>


<br>


<i>I XXX roll the wheel from the XXXy to the XXX.</i><br>


<br>


If you want full short matching ("wellwall" replaced by XXXXXX), you need to use advanced techniques involving groups.<br>



<h1><a name="_Advanced_Searches_with_Groups"></a>Advanced Searches with Groups</h1>

Let's say you want to find a phone number. Look at all the ways phone numbers can be written:<br>

<ul>


  <li>(800)555-1212</li>
  <li>(800) 555-1212</li>
  <li>(800)-555-1212</li>
  <li>800-555-1212</li>
  <li>555-1212</li>
</ul>


The first thing to notice is that everything except the area code is simple:<br>


<pre>/\d\{3}-\d\{4}<br></pre>

If you notice, either you have an area code plus optional dash or space between
it and the exchange, or you don't. So you make a group to hold the area code,
its parens or lack thereof, and option dash or spac

So anyway, we can start by dreaming of a group containing area code, optional
parens, and an optional trailing separator, and prepending it onto the search
for the exchange and 4 digit number:<br>


<pre>/\(area_code_group\)\?\d\{3}-\d\{4}<br></pre>


Following in the footsteps of programmers since the dawn of time, let's simply
forget about the last 7 digits and concentrate on the area code group.<br>


<br>


One thing you know is the area code has it has parentheses or it doesn't.
The other punctuation depends on whether it has parentheses. If it has parentheses
you look for this:<br>


<pre>/(\d\{3})[- ]\?</pre>


That's an opening paren, exactly three digits, a closing paren, and one or
zero iterations of either a space or a dash. Obviously if there are zero
iterations it matches a string where the paren buts up against the telephone
exchange.<br>


<br>


If there are no parens, it's even simpler because you must have a dash after the area code. <br>


<pre>\d\{3}-</pre>


We'll use the \| operator to represent alternatives. In truth I don't know
whether many VI implementations offer the \| operator, but I know that Vim
does. By the way, in case you haven't noticed, Vim is my favorite VI implementation,
though I like all VI's. Anyway, here's the first step in representing the
area code:<br>


<pre>/(\d\{3})[- ]\?\|\d\{3}-&nbsp; </pre>


This matches area codes with or without parens. Remembering phone numbers
can have one or zero area codes, together with the area code's parens and
optional trailing dash or space, we put that in a group that can happen zero
or one time, and append the regex for the last 7 digits of the phone number:<br>


<pre><b><font size="+1"><font color="#330033">/</font><font color="#330033">\(</font><font color="#330033">(\d\{3})[- ]\?</font><font color="#330033">\|</font><font color="#330033">\d\{3}-</font><font color="#330033">\)</font><font color="#330033">\?</font><font color="#993399"><font color="#330033">\d\{3}-\d\{4}</font></font></font></b></pre>


To make this clearer, let's color code it:<br>


<pre><font size="+1"><b>/<font color="#cc0000">\(</font><font color="#006600">(\d\{3})[- ]\?</font><font color="#ff6600">\|</font><font color="#000099">\d\{3}-</font><font color="#cc0000">\)</font><font color="#339999">\?</font><font color="#993399">\d\{3}-\d\{4}</font></b></font><br></pre>


<br>


<table cellpadding="2" cellspacing="2" border="1">


  <tbody>
    <tr>
      <td valign="middle" align="right" bgcolor="#cccccc"><b>Color<br>
      </b></td>
      <td valign="middle" align="center" bgcolor="#cccccc">
      <pre><b>Regex<br></b></pre>
      </td>
      <td valign="middle" bgcolor="#cccccc"><b>Explanation<br>
      </b></td>
    </tr>
    <tr>
      <td valign="middle" align="right"><b><font color="#cc0000">red<br>
      </font></b></td>
      <td valign="middle" align="center">
      <pre><b><font color="#cc0000">\( to \)<br></font></b></pre>
      </td>
      <td valign="middle"><b><font color="#cc0000">Group &nbsp;consisting of all area code and trailing punctuation alternatives</font><br>
      </b></td>
    </tr>
    <tr>
      <td valign="middle" align="right"><b><font color="#00cccc">turquoise<br>
      </font></b></td>
      <td valign="middle" align="center">
      <pre><b><font color="#00cccc">\?<br></font></b></pre>
      </td>
      <td valign="middle"><b><font color="#00cccc">Signifies 0 or 1 instances of the area code group.<br>
      </font></b></td>
    </tr>
    <tr>
      <td valign="middle" align="right"><b><font color="#993399">magenta</font></b></td>
      <td valign="middle" align="center">
      <pre><b><font size="+1"><font color="#993399">\d\{3}-\d\{4}</font></font></b></pre>
      </td>
      <td valign="middle"><b><font color="#993399">Phone number without area code</font></b></td>
    </tr>
    <tr>
      <td valign="middle" align="right"><b><font color="#ff6600">orange</font></b></td>
      <td valign="middle" align="center">
      <pre><b><font size="+1"><font color="#ff6600">\|</font></font></b></pre>
      </td>
      <td valign="middle"><b><font color="#ff6600">Signifies that the element on its left and on its right are either/or alternatives</font></b></td>
    </tr>
    <tr>
      <td valign="middle" align="right"><b><font color="#006600">green</font></b></td>
      <td valign="middle" align="center">
      <pre><b><font size="+1"><font color="#006600">(\d\{3})[- ]\?</font></font></b></pre>
      </td>
      <td valign="middle"><b><font color="#006600">Structure (with options) of area code with parens</font></b></td>
    </tr>
    <tr>
      <td valign="middle" align="right"><b><font color="#000099">blue</font></b></td>
      <td valign="middle" align="center">
      <pre><b><font size="+1"><font color="#000099">\d\{3}-</font></font></b></pre>
      </td>
      <td valign="middle"><b><font color="#000099">Structure of the area code without parens</font><br>
      </b></td>
    </tr>
  </tbody>
</table>


<br>


Groups can be nested, and nested, and nested some more. In VI implementations
that allow it, alternative groups can be specified with the \| operator (or
possibly a different operator in a different VI implementation).<br>


<br>


If your head doesn't hurt too badly, for extra credit try to make a substitute
expression that converts all these phone number formats to a single format.
I can't do it in a single step, but I can do it in a 2 step process. The
first substitute finds all valid phone numbers and surrounds them with <tt>pho_</tt> on one side and <tt>_ohp</tt>
on the other. The second finds such surrounded strings and picks off the
digits. This 2 stage approach frees the second replace from worrying about
punctuation, or mixing detection and validation with substitution.<br>


<br>


To do this, step 1 must surround the ENTIRE search expression with \( and
\) to make it a single group, and place it in a substitute:<br>


<br>


<pre><b>:%s/\(\((\d\{3})[- ]\?\|\d\{3}-\)\?\d\{3}-\d\{4}\)/pho_\1_ohp/</b></pre>


Step 2 formats all resulting strings that include area codes in a standard format:<br>


<pre><b>:%s/pho_\D*\(\d\d\d\)\D*\(\d\d\d-\d\d\d\d\)_ohp/(\1)-\2/</b><br></pre>
You'll notice that all phone numbers that didn't include an area code were
not converted. To convert them you need to run a second, much simpler substitute
command.<br>
<br>


I think you know where I'm going with this. If we can recognize all forms
of phone numbers, and we can also remember matched text for use in the replace
expression, then it's pretty obvious we can make a regular expression to
"standardize" phone numbers. In this case we need to surround the digits
of the phone number with slash parens. It's made more difficult because those
slash parens are nested in a major group and are alternatives. <br>


<h2>Scripts</h2>

<table cellpadding="2" cellspacing="2" border="1">

  <tbody>
    <tr>
      <td valign="top">
      <pre><b>:/search</b></pre>
      </td>
      <td valign="top">Search forward and goto the first matching line<br>
      </td>
    </tr>
    <tr>
      <td valign="top">
      <pre><b>:?search</b></pre>
      </td>
      <td valign="top">Search backward and goto the first matching line<br>
      </td>
    </tr>
    <tr>
      <td valign="top">
      <pre><b>:g/search/cmd</b></pre>
      </td>
      <td valign="top">The global command.</td>
    </tr>
    <tr>
<tr>
      <td valign="top">
      <pre><b>:!sysCmd</b></pre>
      </td>
      <td valign="top">Filters lines through an operating system command. The lines in the range are sent to the command, and are replaced by the output of the command. Common examples:<br>
      <table cellpadding="2" cellspacing="2" border="1">
        <tbody>
          <tr>
            <td valign="top" bgcolor="#cccccc">sysCmd<br>
            </td>
            <td valign="top" bgcolor="#cccccc">RESULT<br>
            </td>
          </tr>
          <tr>
            <td valign="top">:%sort<br>
            </td>
            <td valign="top">Sort the file<br>
            </td>
          </tr>
          <tr>
            <td valign="top">:%sort -n<br>
            </td>
            <td valign="top">Sort file numerically<br>
            </td>
          </tr>
          <tr>
            <td valign="top">:%sort -u<br>
            </td>
            <td valign="top">Sort unique -- delete dups<br>
            </td>
          </tr>
          <tr>
            <td valign="top">:cat -n<br>
            </td>
            <td valign="top">Prepend line numbers to each line<br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
      </td>
    </tr>
    <tr>
      <td valign="top"><b><tt>:normal ddp</tt></b><br>
      </td>
      <td valign="top">Example to the left switches the current line with the one below it. <tt>:normal</tt> runs a command mode Vim command from the EX prompt. This is not in VI, but it is in Vim and possibly other implementations.<br>
      </td>
    </tr>

  </tbody>
</table>





</body></html>
