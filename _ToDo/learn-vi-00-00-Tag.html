<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh" xml:lang="zh">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<link rel="stylesheet" type="text/css" href="learn-vi.css" />
	<title>VIM学习笔记  ()</title>
</head>
<body>
	<h1>VIM学习笔记  ()</h1>
    <p><a href="http://ctags.sourceforge.net/" title="ctags">Ctags</a></p>

<h2 id="what-is-ctags"><a class="anchor" aria-hidden="true" href="#what-is-ctags">🔗</a>What is ctags?</h2>
http://ctags.sourceforge.net/languages.html
<p>Ctags is a tool that extracts important constructs from the code you’re working
on. If you’re coding in ruby, it’ll find methods, classes and modules. With
vimscript, it pulls out functions, commands and mappings. The extracted data is
dumped in a file called “tags” by default, which has a single item per line –
a “tag”. Depending on the command-line flags and the programming language, you
could get a lot of information out of these. For example, with C++ and Java,
ctags can save the inheritance chain for a class. A text editor can then easily
use that for code navigation and completion.</p>

<h2 id="installation-and-simplest-use-case"><a class="anchor" aria-hidden="true" href="#installation-and-simplest-use-case">🔗</a>Installation and simplest use case</h2>

<p>The actual program is called “Exuberant ctags”, since it’s a rewrite of the original one.</p>

<ul>
  <li>对于Mac<code class="highlighter-rouge">brew
install ctags</code> or <code class="highlighter-rouge">port install ctags</code>.</li>
  <li>On Linux, I’ve yet to see a package manager that doesn’t provide ctags.</li>
  <li>On Windows, just download the binary from
<a href="http://ctags.sourceforge.net/">the homepage</a> choco install ctags.</li>
</ul>

<p>Assuming the executable is in your <code class="highlighter-rouge">PATH</code> (it might not be if you’re running
Windows), you can simply go to a directory with some code and run:</p>
	<p>使用以下命令，可以针对指定文件生成tags文件：</p>
	<p style="text-indent:2em"><code class="inset">:!ctags HTML.vim</code></p>
	<p>你也可以针对当前目录及其子目录中的所有文件生成tags文件：</p>
	<p style="text-indent:2em"><code class="inset">:!ctags -R .</code></p>

	<p>使用以下命令，可以直接跳转到定义函数的位置：</p>
	<p style="text-indent:2em"><code class="inset">:tag <var>name</var></code></p>
	<p>在常规模式下，使用<kbd>Ctrl-]</kbd>快捷键，将查找光标下的标签（比如函数或宏等），并跳转到定义该标签的位置：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Foo</span>
  <span class="k">def</span> <span class="nf">bar</span>
    <span class="s2">"baz"</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">Foo</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">bar</span>
</code></pre></div></div>

<p>If the cursor is on <code class="highlighter-rouge">Foo</code> at the <code class="highlighter-rouge">Foo.new.bar</code> line and you type <code class="highlighter-rouge">&lt;C-]&gt;</code>, vim
will jump on the <code class="highlighter-rouge">class Foo</code> line. This works across files as well. To get back
to where you followed something, just type <code class="highlighter-rouge">&lt;C-t&gt;</code> in normal mode. Using these
two mappings, you can navigate your entire project pretty easily. Note that
it’s extremely fast, even if you have a large tag file. That’s because the tags
are sorted and vim uses a binary search to quickly locate them. It’s simple and
highly effective.</p>

<h2 id="multiple-matches"><a class="anchor" aria-hidden="true" href="#multiple-matches">🔗</a>Multiple matches</h2>

<p>If you have multiple definitions for a tag, the default <code class="highlighter-rouge">&lt;C-]&gt;</code> behavior is to
drop you off at the first one it finds. By default, vim gives more priority to
tags in the current file, which is often what you want. While doing that,
you’ll also be shown a message:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tag 1 of x or more
</code></pre></div></div>

<p>There are various ways to jump through the rest of the matches:</p>

<ul>
  <li><code class="highlighter-rouge">:tnext</code> and <code class="highlighter-rouge">:tprev</code> will send you to the next and previous tag in the
list, respectively.</li>
  <li><code class="highlighter-rouge">:tselect</code> will display the tag list and let you choose one with a number.</li>
  <li><code class="highlighter-rouge">:ltag</code> will load the tags into the location list window. You can then view
that window by executing <code class="highlighter-rouge">:lopen</code>.</li>
</ul>
<p>These commands will also accept regular expressions, so, for example, <code class="inline">:tag /^asserts_*</code> would find all tags that start with ‘asserts_’. By default vim will
jump to the first result, but a number of commands can be used to sort through
the list of tags:</p>
<ul>
<li><code class="inline">:ts</code> or <code class="inline">:tselect</code> shows the list
</li>
<li><code class="inline">:tn</code> or <code class="inline">:tnext</code> goes to the next tag in that list
</li>
<li><code class="inline">:tp</code> or <code class="inline">:tprev</code> goes to the previous tag in that list
</li>
<li><code class="inline">:tf</code> or <code class="inline">:tfirst</code> goes to the first tag of the list
</li>
<li><code class="inline">:tl</code> or <code class="inline">:tlast</code> goes to the last tag of the list
</li>
</ul>
<p>To show the tags you’ve traversed since you opened vim, run <code class="inline">:tags</code>.</p>
<p>For an easier time, you could always create some shortcuts. For example, you
could follow the convention of the
<a href="http://www.vim.org/scripts/script.php?script_id=1590">unimpaired.vim</a>
plugin and map <code class="highlighter-rouge">]t</code> for <code class="highlighter-rouge">:tnext</code> and <code class="highlighter-rouge">[t</code> for <code class="highlighter-rouge">:tprev.</code></p>

<h2 id="dynamic-tags-and-autotag"><a class="anchor" aria-hidden="true" href="#dynamic-tags-and-autotag">🔗</a>Dynamic tags and autotag</h2>

<p>I’m going to call the tags generated for your code “dynamic”, since you’re
probably constantly making changes there. So, what happens when the tags are no
longer correct? While you could regularly invoke ctags on the working
directory, that’s going to get annoying pretty fast. Thankfully, the tool has
an <code class="highlighter-rouge">-a</code> flag that makes it append to a tag file instead of overwriting it. That
way, you can update the tags very quickly every time a file changes. With vim’s
autocommands, this could work like this:</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code>autocmd <span class="nb">BufWritePost</span> *
<span class="se">      \</span> <span class="k">if</span> filereadable<span class="p">(</span><span class="s1">'tags'</span><span class="p">)</span> <span class="p">|</span>
<span class="se">      \</span>   <span class="k">call</span> system<span class="p">(</span><span class="s1">'ctags -a '</span><span class="p">.</span>expand<span class="p">(</span><span class="s1">'%'</span><span class="p">))</span> <span class="p">|</span>
<span class="se">      \</span> <span class="k">endif</span>
</code></pre></div></div>

<p>Unfortunately, there’s an issue with this approach. Ctags will only add new
tags, it won’t remove ones that are no longer present. If you delete a
function, it will still appear in the tag file.</p>

<p>That’s where the
<a href="http://www.vim.org/scripts/script.php?script_id=1343">autotag.vim</a>
plugin comes in. Whenever you save a file, it deletes all of its entries and
invokes ctags in append mode. I’ve been using it for a long time and I haven’t
noticed any overhead at all, even on Windows boxes. Unfortunately, your vim
build needs to have python support to use it. Even if it doesn’t, though, no
errors are raised, which is nice if you use the same vimfiles across different
vim builds like I do.</p>

<h2 id="static-tags"><a class="anchor" aria-hidden="true" href="#static-tags">🔗</a>Static tags</h2>

<p>Another way you could use ctags is to index libraries that your project uses,
assuming you have their source locally. For example, until recently, I would
checkout the rails source code at <code class="highlighter-rouge">~/src/rails</code>, run ctags on it and save the
resulting file as <code class="highlighter-rouge">~/tags/rails.tags</code>. I use the nifty
<a href="http://www.vim.org/scripts/script.php?script_id=2719">Proj plugin</a>
to
source project-specific vimfiles, so I just have to add it to the
<a href="http://vimdoc.sourceforge.net/htmldoc/options.html#%27tags%27">‘tags’</a>
option:</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">set</span> <span class="k">tags</span><span class="p">+=~</span><span class="sr">/tags/</span>rails<span class="p">.</span><span class="k">tags</span>
</code></pre></div></div>

<p>This allows me to easily jump to a definition of a method within the framework
itself. Since rails is pretty well commented, I don’t have to google for method
signatures, at least.</p>

<p>A better approach I eventually discovered was generating tags for <em>all gems</em> I
was using. Of course, I can’t build an index of every single gem on my system.
There are different versions installed side-by-side and I’d get a whole lot of
duplication (if nothing else). But since bundler made its way into ruby, the
Gemfile always contains a nice snapshot of all gems your particular application
is using. Thankfully, we don’t have to parse the actual file for that.
<a href="https://gist.github.com/893236">This little ruby snippet</a>
taps into bundler’s API to retrieve the gem locations and builds the tag file:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'bundler'</span>

<span class="n">paths</span> <span class="o">=</span> <span class="no">Bundler</span><span class="p">.</span><span class="nf">load</span><span class="p">.</span><span class="nf">specs</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:full_gem_path</span><span class="p">)</span>

<span class="nb">system</span><span class="p">(</span><span class="s2">"ctags -R -f gems.tags </span><span class="si">#{</span><span class="n">paths</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s1">' '</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</code></pre></div></div>

<p>Even if this script is specific to ruby, the general approach could be used for
any kind of project. Just maintain a list of all libraries your application is
using, find them locally and run ctags on that.</p>

<h2 id="code-completion"><a class="anchor" aria-hidden="true" href="#code-completion">🔗</a>Code completion</h2>

<p>Vim has quite a few completion types to deal with different situations, but
<a href="http://vimdoc.sourceforge.net/htmldoc/insert.html#compl-omni">omnicompletion</a>,
which is meant to intelligently decide what to do, is just not very good
 for some languages. That’s why, whenever I want to complete a method 
call or class name that I know is defined somewhere, I just use
<a href="http://vimdoc.sourceforge.net/htmldoc/insert.html#compl-tag">tag completion</a>:</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code>inoremap <span class="p">&lt;</span><span class="k">c</span><span class="p">-</span><span class="k">x</span><span class="p">&gt;&lt;</span><span class="k">c</span><span class="p">-]&gt;</span> <span class="p">&lt;</span><span class="k">c</span><span class="p">-]&gt;</span>
</code></pre></div></div>

<p>If you’d like to have it appear automatically as you type, you could try the
<a href="http://www.vim.org/scripts/script.php?script_id=1879">Acp plugin</a>.
It’s fast and pretty customizable – you can define the type of completion
you’d like to use per filetype and depending on some specific condition.</p>

<h2 id="accessing-tag-data-in-vimscript"><a class="anchor" aria-hidden="true" href="#accessing-tag-data-in-vimscript">🔗</a>Accessing tag data in vimscript</h2>

<p>If you’d like to use the tags for your own custom needs, vim provides a
straightforward way to do that through the
<a href="http://vimdoc.sourceforge.net/htmldoc/eval.html#taglist\(\)">taglist</a>
function. It’s called with a regular expression and it will return all the data
from the matching tags in the form of a list of dictionaries. An example of
what you could do with it is the following command, which finds function
definitions:</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code>command<span class="p">!</span> <span class="p">-</span>nargs<span class="p">=</span><span class="m">1</span> Function <span class="k">call</span> <span class="nv">s:Function</span><span class="p">(&lt;</span><span class="k">f</span><span class="p">-</span>args<span class="p">&gt;)</span>
<span class="k">function</span><span class="p">!</span> <span class="nv">s:Function</span><span class="p">(</span>name<span class="p">)</span>
  <span class="c">" Retrieve tags of the 'f' kind</span>
  <span class="k">let</span> <span class="k">tags</span> <span class="p">=</span> taglist<span class="p">(</span><span class="s1">'^'</span><span class="p">.</span><span class="nv">a:name</span><span class="p">)</span>
  <span class="k">let</span> <span class="k">tags</span> <span class="p">=</span> <span class="k">filter</span><span class="p">(</span><span class="k">tags</span><span class="p">,</span> <span class="s1">'v:val["kind"] == "f"'</span><span class="p">)</span>

  <span class="c">" Prepare them for inserting in the quickfix window</span>
  <span class="k">let</span> qf_taglist <span class="p">=</span> <span class="p">[]</span>
  <span class="k">for</span> entry <span class="k">in</span> <span class="k">tags</span>
    <span class="k">call</span> add<span class="p">(</span>qf_taglist<span class="p">,</span> <span class="p">{</span>
<span class="se">          \</span> <span class="s1">'pattern'</span><span class="p">:</span>  entry<span class="p">[</span><span class="s1">'cmd'</span><span class="p">],</span>
<span class="se">          \</span> <span class="s1">'filename'</span><span class="p">:</span> entry<span class="p">[</span><span class="s1">'filename'</span><span class="p">],</span>
<span class="se">          \</span> <span class="p">})</span>
  <span class="k">endfor</span>

  <span class="c">" Place the tags in the quickfix window, if possible</span>
  <span class="k">if</span> len<span class="p">(</span>qf_taglist<span class="p">)</span> <span class="p">&gt;</span> <span class="m">0</span>
    <span class="k">call</span> setqflist<span class="p">(</span>qf_taglist<span class="p">)</span>
    <span class="k">copen</span>
  <span class="k">else</span>
    echo <span class="s2">"No tags found for "</span><span class="p">.</span><span class="nv">a:name</span>
  <span class="k">endif</span>
<span class="k">endfunction</span>
</code></pre></div></div>

<p>Invoking <code class="highlighter-rouge">:Function foo</code> will look for functions in the tag file that start
with “foo” and load them all in the
<a href="http://vimdoc.sourceforge.net/htmldoc/quickfix.html#quickfix">quickfix</a>
window. This could be even more useful with some tab-completion and it’s also
not very portable across filetypes. It shouldn’t be too difficult to generalize
it a bit, so I might devote a separate blog post for that when I get around to
doing it.</p>

<h2 id="summary"><a class="anchor" aria-hidden="true" href="#summary">🔗</a>Summary</h2>

<ul>
  <li>You can use ctags to index the code you’re working on. The autotag plugin
can keep the tag file up to date, but you need a vim with python support
for that.</li>
  <li>Generating tags for any libraries you’re using is even easier, since they
won’t be changing any time soon. A potential problem is figuring out a way
to add the extra tag files just where you need them.</li>
  <li>Tag completion can often be good enough when you can’t remember an exact
name for a function or class.</li>
  <li>Accessing the tag data for your own hardcore customization needs is done
through the <code class="highlighter-rouge">taglist</code> function.</li>
</ul>

For more on this stuff, run <code class="inline">:help tags</code> and <code class="inline">:help CTRL-]</code>
https://vim.fandom.com/wiki/Browsing_programs_with_tags
假如我们正在看一个程序文件,但是却碰到一个我们并不理解的函数调用.我们可以用命令CTRL-]跳转到函数定义的地方.但是这样做却有一个问题,那就当前的文件被函数定义的内容所替代,我们也就不可以从屏幕上看到这个文件的内容了.
这个问题的一个解决办法就是我们使用被称为preview的特殊窗口.我们可以通过执行下面的命令来打开preview的特殊窗口,在这个窗口中显示函数定义的内容:
:ptag function
如果我们已经打开了一个preview窗口,那么他就会切换到当前正在查看的函数定义内容.如果我们要关闭这个窗口,我们可以执行下面的命令:
:pclose
命令CTRL-Wz和ZZ也可以有关闭这个窗口的作用.
在preview窗口中我们执行下面的命令来完成我们的工作:
:ppop        在这个窗口中执行一个:pop命令.
:ptselect identifier    打开一个新的preview窗口并执行:tselect命令
:ptjump identifier    打开一个新的preview窗口并执行:ptjump 命令
:count ptnext        在这个窗口中执行:count tnext命令
:count ptprevious    在这个窗口中执行:count ptprevious命令
:count ptrewind        在这个窗口中执行:count ptrewind命令
:ptlast            在这个窗口中执行:ptlast命令.
CTRL-W}            以当前光标下的内容执行一个:ptag命令
CTRL-Wg}        以当前光标下的内容执行一个:ptjump命令
	<p style="text-indent:2em"><code class="inset"></code></p>



<	A more exotic example, to jump between the '=' and ';' in an
	assignment, useful for languages like C and Java: >
		:au FileType c,cpp,java set mps+==:;
	<p>matchpairs选项，用来控制哪些字符可以通过<code class="inset">%</code>命令进行匹配。此选项的默认值如下：</p>
	<p style="text-indent:2em"><code class="inset">:set matchpairs=(:),{:},[:]</code></p>
	<p>也就是说，在开括号&ldquo;(,{,[&rdquo;上点击<code class="inset">%</code>命令，那么将自动跳转到对应的闭括号上&ldquo;),},]&rdquo;；同理，在闭括号上点击<code class="inset">%</code>命令，则将跳转回到对应的开括号上；同时，匹配跳转也会正确处理括号嵌套的情况。</p>
	<p>如果需要新增匹配类型，例如增加对于HTML文件中的尖括号的匹配，那么可以使用以下命令：</p>
	<p style="text-indent:2em"><code class="inset">:set mps+=&lt;:&gt;</code></p>
这个命令仅仅是匹配<>.如果我们要同时匹配其他的字符,我们可以用下面的命令:
:set matchpairs=(:),{:},[:],<:>
	<p style="color:gray; font-size:0.6em"><a href="http://yyq123.github.io/learn-vim/images/matchit-vim-example.gif" title="matchit-vim-example"><img src="http://yyq123.github.io/learn-vim/images/matchit-vim-example.gif" alt="" /></a></br>Source: https://catonmat.net/vim-plugins-matchit-vim</p>
<p></p>
如果我们希望我们在输入括号时,光标会跳转到与其匹配的地方进行显示,我们可以执行下面的命令来做到:
	<p style="text-indent:2em"><code class="inset">:set showmatch</code></p>

通常情况下这个跳转持续的时间为0.5秒(半秒),我们可以用matchtime选项来控制这个时间.例如如果我们希望这个时间持续1.5秒,我们可以用下面的命令:
:set matchtime=15
在这里是以0.1秒为单位的.
<p></p>
我们在Vim编辑器还可以用命令来查找未匹配的括号.如[{查找前一个未匹配的{,]{查找后一个未匹配的{.[}查找前一个未匹配的},而]}查找后一个未匹配的}.
])查找后一个未匹配的),而[(查找前一个未匹配的(.[#查找前一个未匹配的#if或者是#else.而]#查找后一个未匹配的同类情况.
下面的命令可以移动一个Java方法的开头或结尾:
[m    向后查找一个方法的开头
[M    向后查找一个方法的结尾
]m    向前查找一个方法的开头
]M    向前查找一个方法的结尾
在Vim编辑器还提供了许多的移动命令来帮助程序人员在他们的程序文件中进行浏览.下面的一些命令可以找到位于第一列的{和}:
count[[        向后查找位于第一列的前一个{
count[]        向后查找位于第一列的前一个}
count]]        向前查找位于第一列的后一个{
count][        向前查找位于第一列的后一个}
命令[/和[*可向后移动他可以找到的第一个C注释的开始处,而]/和]*可以向前移动他可以找到下一个C注释的结束处.
include选项可以用来为我们使用命令]CTRL-I,[CTRL-I,]d,[d在这些我们所包含进来的文件中进行查找.这个选项也可以为命令:checkpath所用.
命令[i用来查找光标下的内容第一次出现的地方.注释的文本会被忽略掉.
命令]j用来查找光标下的内容下一次出现的地方.注释的文本会被忽略掉.
命令[I会列出所有包含当前光标下的内容的句子,命令]I与其相类似,只是这个命令是从当前光标处开始.
:make命令会产生一个错误列表.Vim编辑器会记住我们前10次:make命令和:grep命令的执行结果.如果我们要到前一次的错误列表,我们可以用下面的命令:
:colder
如果我们要到一个新的错误列表,我们可以用下面的命令:
:cnewer
当我们执行:make命令时所要执行的程序名称是由makeprg选项来定义的.在通常的情况下会设为make,但是Visual C++的用户可以通过下面的命令将其设为nmake:
:set makeprg=nmake
:make命令会重定向Make的输出到一个错误文件.这个文件的名字是由makeef选项来控制的.如果这个选项包含有字符##,字符##就会被专一的数字所代替.这个选项默认的值取决于我们正在使用的操作系统.默认的值如下:
Amiga        t:vim##.Err
UNIX        /tmp/vim##.err
Windows        vim##.err
我们可以在命令中包含指定的Vim关键字.%字符可以扩展当前文件的名字,所以我们执行下面的命令:
:set makeprg=make%
然后我们执行命令:
:make
他就会执行下面的命令:
$ make file.c
file.c就是我们正在编辑的文件的名字.这个并没有太大的用处,所以我们可以重新定义这个命令并使用:r(root)的权限:
:set makeprg=make%:r.o
这样我们就会执行下面的命令:
$ make file.o
选项errorformat可以用来控制Vim如何来组织错误文件以使得他可以知道文件名以及错误发生的地方.这个选项的格式如下:
:set errorformat={string},{string},{string}
这里的字符是由特殊字符%所指出的典型的错误信息用来指明特殊的操作(与标准C函数scanf很相像).这些特殊的字符如下:
%f    文件名
%l    行号
%c    列号
%t    错误类型(单一字符)
%n    错误行号
%m    错误信息
%r    匹配一行中的剩余
%*{char}匹配并跳过由{char}所指定的scanf转换
%%    字符%
当我们在编译一个程序的时候,我们也许要在几个目录中进行遍历.GNU make程序会在当我们进入一个目录或是离开一个目录时打印出相应的信息.
如果要正确的得到文件名,Vim就要清楚的知道这些目录的变化.下面的一些错误格式用来在目录发生变化时告诉Vim一些相关的信息:
%D    当进入一个目录时打印出指定的信息.字符串的%f指明我们所进入的目录
%X    指定离开目录时的信息.字符串中的%f指明了make已用毕的目录.
一些编译器,例如GNU GCC编译器,会输入一些冗长的错误信息.如果我们正在使用默认的errorformat就会导致三种错误信息.这实在是够讨厌的.但是幸运的是Vim编辑器可以识别出不同的错误信息.处理不同信息的模式代码如下:
%A    开始多行信息
%E    开始多行错误信息
%W    开始多行警告信息
%C    连续多行信息
%Z    结束多行信息
%G    全局.只有在+或是-连接时才有用
%O    单行文件信息:重新读入匹配的部分
%P    单行文件信息:将%f文件压入栈
%Q    单行文件信息:将最后一个文件压出栈
+或是-可以放在任何字符的前面,从而组成下面的内容:
%-letter    不要包含输出中的匹配行
%+letter    包含%m错误字符串的整个匹配行
在通常的情况下,我们执行:make命令并有错误发生,Vim会在当前的窗口中显示错误文件.如果我们通过设置switchbuf选项来进行窗口的分裂,Vim就会在一个新的窗口来显示错误文件..#和%字符会扩展到当前文件名和交替文件名.而字符串$*将会被:grep命令的参数所代替.
编译或者 grep 的时候，信息输出到 Quickfix窗口中，按回车就容易把buf给切换走，使用标签后设置下面一项，即可更改quickfix行为为：如果有已打开文件，先复用，没有的话使用标签：
set switchbuf=useopen,usetab,newtab

在通常的情况下,Vim是使用二分法进行查找指定的标记名字.如果一个标记文件是按序排列的,这样的方法可以是很快速的.否则的话我们可以使用线性查找的方法.如果要强制进行线性查找,我们可以用下面的命令;
:set notagbsearch
这个选项会在我们的标记文件不是有序的时有用.
有一些系统会限制我们在函数名中所使用的字符数.如果我们要在Vim中加入这样的限制,我们可以通过设置taglength选项来限制我们函数名的最大长度.
我们可以用tags选项来指定标记文件名.这个可以用来指其他目录中的文件.如:
:set tags+=/home/oualline/tools/vim/tags
但是这会带来一些令人费解的地方.是我们在当前目录中启动并告诉ctags将标记文件放在目录/home/oualline/tools/vim还是我们在当前的目录执行了ctags呢?现在的Vim编辑器已经用其他的选项来解决了这个问题了.如果我们进行下面的设置,所有的标记都会和含有标记文件的目录有关系:
:set tagrelative
否则的话,他们会和当前目录有关系.
如果我们设置了tagstack选项,那么:tag命令和:tjump命令就会建立一个标记栈.否则是不会保持栈的.
	<p><a href="https://yyq123.github.io/learn-vim/images/.png" title=""><img src="https://yyq123.github.io/learn-vim/images/.png" alt="" width="500" height="" /></a></p>
	<p style="color:gray; font-size:0.6em"><a href="http://yyq123.github.io/learn-vim/images/.png" title=""><img src="http://yyq123.github.io/learn-vim/images/.png" alt="" /></a></br>Source: medium.com/free-code-camp</p>


	<p></p>

	<p></p>
	<p style="text-indent:2em"><code class="inset"></code></p>

	<p><a href="https://yyq123.github.io/learn-vim/images/.png" title=""><img src="https://yyq123.github.io/learn-vim/images/.png" alt="" width="500" height="" /></a></p>

	<table summary="Commands" border="2" frame="hsides" rules="all" cellspacing="0" cellpadding="3">
		<caption>命令小结</caption>
		<tr><td><code class="inset">:</code></td><td rowspan="2"></td></tr>
		<tr><td><code class="inset">:</code></td></tr>
		<tr><td><code class="inset">:</code></td><td></td></tr>
		<tr><td><code class="inset">:</code></td><td></td></tr>
		<tr><td><code class="inset">:</code></td><td></td></tr>
	</table>
&ldquo;&rdquo;

	<p style="border-top:1px solid lightgray"><span style="float:right">Ver: 2.0&nbsp;|&nbsp;<a href="mailto:yyq123@gmail.com">YYQ</a></span><span>&lt;<a title="" href="http://yyq123.github.io/learn-vim/.html">上一篇</a>&nbsp;|<a title="笔记列表" href="http://yyq123.github.com/learn-vim/learn-vi-00-00-TOC.html">&nbsp;目录&nbsp;</a>|&nbsp;<a title="" href="http://yyq123.github.io/learn-vim/.html">下一篇</a>&gt;</span></p>

</body>
</html>
