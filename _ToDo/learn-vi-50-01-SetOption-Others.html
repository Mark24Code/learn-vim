<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh" xml:lang="zh">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<link rel="stylesheet" type="text/css" href="learn-vi.css" />
	<title>VIM学习笔记 设置选项(set-option)</title>
</head>
<body>
	<h1>VIM学习笔记 设置选项(set-option)</h1>

	<p>Vim使用viminfo选项，来定义如何保存session信息。这是一组使用逗号分隔的字符串。</p>

Use the viminfo option to set the location of your _viminfo. eg

:set viminfo=nC:\\_viminfo

	<p style="text-indent:2em"><code class="inset">:help viminfo</code></p>

ViM uses the viminfo file as a memory dump to remember information from the last session. On Windows, this file is named _viminfo and stored in the directory %HOMEDRIVE%/%HOMEPATH.

For example, on a home computer %HOMEDRIVE% might be C: and %HOMEPATH% might be \Users\Joe. Thus, ViM will use C:\Users\Joe\_viminfo

For computers which are connected to a work domain, the %HOMEDRIVE% and %HOMEPATH% are typically set to shared folders on the network. These folders might sometimes be down or slow, causing error messages related to viminfo. Therefore, the default viminfo location on Windows is not appropriate if the computer is on a work domain. A good place for it would be the %LOCALAPPDATA% directory.

To indicate a different viminfo directory to ViM, add this to the vimrc file:
set viminfo+=n$LOCALAPPDATA/_viminfo

The viminfo option is a comma-separated list of parameters. Each parameter is specified by a single character, followed by a number or string that is the value of that parameter. The viminfo file parameter is specified by the letter n, followed by the string that is the path where _viminfo should be stored. Enclosing the path in double quotes does not work! 😡

Note the += operator used to set the viminfo option. The viminfo option already has a bunch of parameters that are specified by default. Thus, we append the viminfo file path parameter to this by using the += operator.

It was indeed in C:\Users\<username>\_viminfo. The command :echo $HOME works a charm as well. 
<p>在<a href="http://yyq123.github.io/learn-vim/learn-vi-59-vimrc.html" title="vimrc">vimrc</a>配置文件中，定义viminfo选项：</p>
set viminfo=%,<800,'10,/50,:100,h,f0,n~/.vim/cache/.viminfo
"           | |    |   |   |    | |  + viminfo文件路径
"           | |    |   |   |    | + file marks 0-9,A-Z 0=NOT stored
"           | |    |   |   |    + hlsearch on (H) or off (h)
"           | |    |   |   + 保存命令历史条数
"           | |    |   + 保存搜索历史条数
"           | |    + files marks saved
"           | + lines saved each register (old name for <, vi6.2)
"           + save/restore buffer list
<p>请注意，。</p>
<ul>
	<li>如果您没有定义/n和:n子选项，那么将使用history选项的值</li>
	<li>建议不要将<n设置过大，因为此选项将影响保存至viminfo文件中的信息量。Vim每次启动时，将读取viminfo文件，过大的文件尺寸，将影响Vim启动速度。</li>
</ul>
<p>在<a href="http://yyq123.github.io/learn-vim/learn-vi-59-vimrc.html" title="vimrc">vimrc</a>文件开头，定义以下选项：</p>
<p style="text-indent:2em"><code class="inset">:set nocompatible</code></p>

<p>viminfo主要包括以下内容：</p>
# Command Line History (newest to oldest)
# Search String History (newest to oldest)
# Expression History (newest to oldest):
# Input Line History (newest to oldest):
# Debug Line History (newest to oldest):
# Registers:
# File marks:
# Jumplist (newest first)
# History of marks within files (newest to oldest)

" These commands open folds
set foldopen=block,insert,jump,mark,percent,quickfix,search,tag,undo

	<p>使用以下命令，可以设置打开文件时显示折叠的层级：</p>
	<p style="text-indent:2em"><code class="inset">:set foldlevelstart=n</code></p>
	<p>其中，<i>n</i>可以设置为以下值：</p>
	<ul>
		<li><strong>-1（默认值）</strong>，设置为负数时，此选项将被忽略；</li>
		<li><strong>0</strong>，所有折叠都是关闭状态；</li>
		<li><strong>99</strong>，所有折叠都是打开状态；如果设置为其他正数时，则打开相应级别的折叠。</li>
	</ul>
选项winaltkeys可以控制Alt键的使用.
例如,如果我们执行了下面的命令,所有的Alt键就可以通过:map命令来使用之成我们命令中的一部分:
:set winaltkeys=no
执行Alt-F并不会选择文件菜单而是执行映射的Alt-F命令.这个可以映射可以是下面的样子:
:map <M-f> :write
在这里我们要知道的就是在Vim中Alt会被叫作M-,Meta的意思.
如果我们执行了下面的命令,所有的Alt键盘就会选择菜单内容而不会执行映射命令了:
:set winaltkeys=yes
第三个选项是yes和no的组合:
:set winaltkeys=menu
在这种模式下,Alt键可以用于选择菜单,也可以用来映射:map命令.所以Alt-F可以选择文件菜单,而我们还可以用Alt-X来映射命令.

果我们设置了more选项,当一个命令的显示会超出一屏时就会显示More提示.如果没有进行设置只是会翻滚屏幕.默认如下:
:set more
下面的命令定义了可以由CTRL-A,CTRL-X识别的数字格式.
:set nrformats=octal,hex
(注:十进制总是可以识别)
如果我们设置了下面的选项,Vim就会试着重新装入终端屏幕的内容.
:set restorescreen
换句话说,他会试着使得我们运行这个程序以后的屏幕看起来就像他运行以前的一样.

" Set the search scan to wrap around the file
set wrapscan

" Set the forward slash to be the slash of note. Backslashes suck
" This is really only applicable to Windows but I like to have a vimrc
" that works no matter what OS I'm currently on
set shellslash

" Allow backspacing over indent, eol, and the start of an insert
set backspace=2


当我们删除或是修改了一些行的文本,如果这些行数超出了report所指定的行数,Vim编辑器就会告诉这一些情况.所以如果我们要Vim报告所有的变化,我们可以用下面的命令:
:set report=0
相反,如果我们不希望Vim来告诉我们这些变化,我们可以将这个值设成一个相当大的值就可了.
我们也可以用下面的命令来设置预览窗口的大小:
:set previewheight={height}


但是如何来处理其他键的顺序呢?我们可以通过下面的两个选项来控制区:
:set timeout
:set ttimeout
下面的是这些设置的作用:
timeout        ttimeout    结果
notimeout    nottimeout    没有超时
timeout        N/A        所有的代码键(<F1>...)以及:map宏超时.
notimeout    ttimeout    只有代码键超时

:set ttimeout=500
这两个选项是告诉Vim在Esc按下后等待1/2秒来决定我们是否还会输入功能键或是等待1秒来决定是否还有其他的键盘映射输入.

	<p><i>timeoutlen</i>选项，即等待后续按键输入的时间，单位为毫秒（millisecond），默认值为1000毫秒，即1秒。如果希望设置键盘等待时间，可以使用以下命令：</p>
	<p style="text-indent:2em"><code class="inset">set timeoutlen=500</code></p>
	<p style="font-weight:bold; border-bottom:1px solid lightgray; border-left:6px solid lightgray; padding:0 0 3px 5px">自定义信息</p>
	<p>Vim使用屏幕底部来显示消息，如果消息长度超出一行是，将会得到类似于&ldquo;按回车继续&rdquo;的提示。通过设置 <i>cmdheight</i> 选项来增加消息的行数，可以显示更多的信息以避免不必要的提示。例如使用以下命令，设置命令行高度为3行：</p>
	<p style="text-indent:2em"><code class="inset">:set cmdheight=3</code></p>
	<p>当Vim捕获一个错误时，将会显示错误信息。如果希望同时发出声音警告，那么可以执行以下命令：</p>
	<p style="text-indent:2em"><code class="inset">:set errorbells</code></p>
	<p>使用以下命令启用visualbell选项，当输入错误时屏幕就会闪动然后回到正常状态：</p>
	<p style="text-indent:2em"><code class="inset">:set visualbell</code></p>
在ex模式下输入命令时,我们可以实现文件名的自动完成.例如如果我们想要读入文件input.txt,我们可以输入下面的命令:
:read input<Tab>
Vim就会试着猜出我们想要的文件.如果在我们当前的目录下只有文件input.txt,他就会显示出如下的形式:
:read input.txt
如果在当前目录下有几个带有input的文件名,则会显示第一个.如果我们再按下Tab,就会显示出第二个相匹配的结果,再按下Tab就会显示第三个.
我们可以通过下面的命令来定义完成通配符的键:
:set wildchar=character
如果我们是在一个宏内使用文件名,我们要设置wildcharm.这是我们在宏内完成文件名自动完成的字符.例如下面的命令:
:set wildcharm=<F12>
:map<F11> :read in<F12>
这样当我们按下F11时就会读入文件命令.
也许我们并不希望匹配备份文件或是其他类似的文件.我们可以用下面的命令来告诉Vim哪些是这样的文件:
:set wildignore=pattern,pattern
这样与指定类型相匹配的文件都会被忽略掉.例如我们要忽略目录文件和备份文件,我们可以用下面的命令:
:set wildignore=*.o,*.bak
suffixes选项会列出一系列文件名的前缀,当遇到这样的前缀时就会得到一个较低的优先级.换句说就是如果一个文件名有这样的前缀就会在匹配时就会一个来显示.
一般情况下,文件名的完成代码并不会显示一个匹配列表.如果我们设置下面的选项:
:set wildmenu
当我们试着要完成一个文件名时,就会在窗口的状态行显示一个可能的文件菜单.
我们可以通过方向键来完成选择.在一行最末的>表明在右部有更多的选择.下键可以使得编辑器进入一个目录.上键回到父目录,回车选择项目.
我们可以通过使用wildmode选项来自定义文件完成功能的行为.下面的命令使得Vim只完成第一个的匹配:
:set wildmode=
如果我们一直按下wildchar键,则只会显示第一个匹配的结果.
而下面的命令则会用他可以查找到的第一个文件来完成文件名:
:set wildmode=full
这样以后,如果我们一直按下wildchar键,其他的匹配文件就会按顺序来显示.
下面的命令则会匹配最长的子串:
:set wildmode=longest
当我们执行下面的命令时会完成同样的功能,但是只是显示那些位于wildmenu中的文件:
:set wildmode=longest:full
下面的命令则会显示一个可能的文件列表:
:set wildmode=list
这种模式并不会匹配完成.如果我们希望这样的情况,我们可以使用下面的选项:
:set wildmode=list:full
最后要完成最长的子串并列出文件,我们可以使用下面的选项:
:set wildmode=list:longest
当我们设置了startofline选项,屏幕的移动命令与一些光标的移动命令例H,M,L,G相同.
如果我们设置了write选项,我们可以使Vim保存文件.如果我们没有设置这个选项,我们只可以查看文件.如果我们希望Vim作为一个安全的查看者,这样的设置是相当有用的.


	<p><a href="https://yyq123.github.io/learn-vim/images/.png" title=""><img src="https://yyq123.github.io/learn-vim/images/.png" alt="" width="500" height="" /></a></p>
	<p>如果希望查看某个选项的当前值，那么可以使用 :set option? 命令，其返回值将显示在屏幕底部。例如：</p>
	<p style="font-weight:bold; border-bottom:1px solid lightgray; border-left:6px solid lightgray; padding:0 0 3px 5px">显示状态</p>
	<p>使用以下命令设置showmode选项，将可以在屏幕底部显示当前所处的状态：</p>
	<p style="text-indent:2em"><code class="inset">:set showmode</code></p>
	<p>如果顺序执行这些命令，那么选项变化如下图所示：</p>
	<p><a href="https://yyq123.github.io/learn-vim/images/setoption_bl.png" title="setoption_boolean"><img src="https://yyq123.github.io/learn-vim/images/setoption_bl.png" alt="setoption_bl" /></a></p>

	<p style="font-weight:bold; border-bottom:1px solid lightgray; border-left:6px solid lightgray; padding:0 0 3px 5px">命令行</p>

	<p>使用以下命令启用showcmd选项，将会在输入命令时，在屏幕底部显示出部分命令：</p>
	<p style="text-indent:2em"><code class="inset">:set showcmd</code></p>
	<p>例如希望输入fx命令来查找字符&ldquo;x&rdquo;，当我们输入f时就会在底部显示f，这对于我们输入较为复杂的纵使时就会显示尤为有用.</p>
	<p><a href="https://yyq123.github.io/learn-vim/images/setoption_num.png" title="setoption_num"><img src="https://yyq123.github.io/learn-vim/images/setoption_num.png" alt="setoption_num" /></a></p>

	<p style="font-weight:bold; border-bottom:1px solid lightgray; border-left:6px solid lightgray; padding:0 0 3px 5px">打印设置</p>
	<p>使用<code class="inset">:hardcopy</code>命令<a href="http://yyq123.github.io/learn-vim/learn-vi-07-Print.html" title="print">打印</a>文件时，将根据<i>printheader</i>选项来定义页眉格式。其默认值为"%&lt;%f%h%m%=Page %N"，将在页眉中显示以下信息：</p>
	<p><a href="https://yyq123.github.io/learn-vim/images/set_printheader_default.png" title="set_printheader_default"><img src="https://yyq123.github.io/learn-vim/images/set_printheader_default.png" alt="set_printheader_default" width="525" height="103" /></a></p>
	<ul>
		<li><i>File name</i>，文件名；</li>
		<li><i>Help buffer flag</i>，如果当前缓冲区打开的是帮助文件，将显示&ldquo;[help]&rdquo;；</li>
		<li><i>Modified flag</i>，如果当前文件已被更改（modified），将显示&ldquo;[+]&rdquo;；如果当前文件不可编辑（nomodifiable），将显示&ldquo;[-]&rdquo;</li>
		<li><i>Page number</i>，页码。</li>
	</ul>
	<p>使用以下命令，可以设置在页眉中打印当前日期和时间：</p>
	<p style="text-indent:2em"><code class="inset">set printheader=%&lt;%f%h%m%40{strftime(\"%I:%M:%S\ \%p,\ %a\ %b\ %d,\ %Y\")}%=Page\ %N</code></p>
	<p>使用以下命令，可以设置在页眉中打印文件最后修改时间：</p>
	<p style="text-indent:2em"><code class="inset">set printheader=%&lt;%f%h%m%40{strftime(\"%c\",getftime(expand(\"%%\")))}%=Page\ %N</code></p>
	<p>使用以下命令，可以设置页眉为空（请注意，命令末尾包括一个空格）：</p>
	<p style="text-indent:2em"><code class="inset">:set printheader=\&nbsp;</code></p>

	Vim can be requested to wrap the text using :set wrap command. However, this is only for display and the text width used for wrapping is the width of the terminal or window that Vim is using. This has no effect on printing.

What we need to do is to set a text width and reformat the text by enforcing this text width. Note that you will need to check how many columns of text width will fit into the printed page for your font, font size and paper size.

    First, we set the text width. Let me assume that 80 columns works for my setup:

1
	
:set textwidth=80

    Next, we ask Vim to reformat the entire text file by enforcing this text width:

1
2
3
	
gg
gq
G

The breakdown of this command is: gg moves cursor to first line of file. gq is the command to reformat all text from current position to the position specified after this. G is the command to move to last line of file. When applied after gq, this reformats the entire file from first line to last line, enforcing the text width we specified earlier.

The formatted file can now be printed. After printing, you can undo this reformatting if it is not needed.

For more details about these commands:
1
2
3
	
:help textwidth
:help gq
:help wrap



	<table summary="Commands" border="1" frame="border" rules="all" cellspacing="0" cellpadding="3">
		<tr><th>命令形式</th><th>描述</th><th>示例</th></tr>
		<tr><td><code class="inset"></code></td><td></td><td><code class="inset"></code></td></tr>
	</table>
	<p>：</p>
	<p><a href="https://yyq123.github.io/learn-vim/images/" title=""><img src="https://yyq123.github.io/learn-vim/images/" alt="" /></a></p>
	<p style="text-indent:2em"><code class="inset"></code></p>
	<p>使用<code class="inset">:help set-option</code>命令，可以查看设置选项的更多帮助信息。</p>


</body>
</html>
